<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/utils/color.js - Pocketknife UI</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css" id="site_custom">
    <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">
<div class="github-fork-ribbon-wrapper right">
    <div class="github-fork-ribbon">
        <a href="https://github.com/sw4/pocketknife/" target="_new"><i class='fa fa-github' style='margin-right:10px;'></i>Contribute!</a>
    </div>
</div>
<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Pocketknife UI"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/pk.html">pk</a></li>
            
                <li><a href="../classes/pk.accordian.html">pk.accordian</a></li>
            
                <li><a href="../classes/pk.carousel.html">pk.carousel</a></li>
            
                <li><a href="../classes/pk.chart.html">pk.chart</a></li>
            
                <li><a href="../classes/pk.checkbox.html">pk.checkbox</a></li>
            
                <li><a href="../classes/pk.color.html">pk.color</a></li>
            
                <li><a href="../classes/pk.colorpicker.html">pk.colorpicker</a></li>
            
                <li><a href="../classes/pk.datepicker.html">pk.datepicker</a></li>
            
                <li><a href="../classes/pk.drag.html">pk.drag</a></li>
            
                <li><a href="../classes/pk.modal.html">pk.modal</a></li>
            
                <li><a href="../classes/pk.notify.html">pk.notify</a></li>
            
                <li><a href="../classes/pk.rating.html">pk.rating</a></li>
            
                <li><a href="../classes/pk.scroll.html">pk.scroll</a></li>
            
                <li><a href="../classes/pk.select.html">pk.select</a></li>
            
                <li><a href="../classes/pk.slider.html">pk.slider</a></li>
            
                <li><a href="../classes/pk.svg.html">pk.svg</a></li>
            
                <li><a href="../classes/pk.switch.html">pk.switch</a></li>
            
                <li><a href="../classes/pk.toggle.html">pk.toggle</a></li>
            
                <li><a href="../classes/pk.tooltip.html">pk.tooltip</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/pocketknife.html">pocketknife</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/utils/color.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var pk = pk || {};
/**
Utility class for converting color types and generating color schemes. 

&lt;div class=&#x27;info-well&#x27;&gt;
For color conversion methods, where the expected parameter is an array e.g &#x60;[0,0,0]&#x60;, the method can also be passed a comma separated value string, e.g. &#x60;&#x27;0,0,0&#x27;&#x60;, from which an array will automatically be extrapolated.
&lt;/div&gt;

@class pk.color
*/

(function(pk) {
    pk.color = {

        /**
        Convert a HEX color string to an RGB

            var color=pk.color.hex2rgb(&#x27;#FF0000&#x27;);
            // color = [255,0,0]

        @method hex2rgb 
		@param hex {String} HEX color string 
        @return {Array} Returns array of red, blue and green components
        */
        hex2rgb: function(hex) {
		
            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
                result, r, g, b;
				
			
            hex = hex.replace(shorthandRegex, function(r, g, b) {
                return r + r + g + g + b + b;
            });
            result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            r = parseInt(result[1], 16);
            g = parseInt(result[2], 16);
            b = parseInt(result[3], 16);
            return [r, g, b];
        },
        /**
        Convert an RGB array to a HEX color string

            var color=pk.color.rgb2hex([255,0,0]);
            // color = &#x27;#FF0000&#x27;

        @method rgb2hex
        @param rgb {Array} Array of red, blue and green components
        @return {String} Returns HEX color string
        */
        rgb2hex: function(rgb) {
			rgb=pk.toArr(rgb);
            var hex = &#x27;&#x27;,
                h, i, c;
            for (i = 0; i &lt; rgb.length; i += 1) {
                c = rgb[i];
                h = c.toString(16);
                h = (h.length === 1) ? &quot;0&quot; + h : h;
                hex += h;
            }
            return &#x27;#&#x27; + hex;
        },
        /**
        Convert an RGB array to a HSV array

            var color=pk.color.rgb2hsv([255,0,0]);
            // color = [0,100,100]

        @method rgb2hsv
        @param rgb {Array} Array of red, blue and green components
        @return {Array} Returns array of hue, saturation and value components
        */
        rgb2hsv: function(rgb) {		
			rgb=pk.toArr(rgb);
            var
                r = rgb[0],
                g = rgb[1],
                b = rgb[2],
                min = Math.min(r, g, b),
                max = Math.max(r, g, b),
                delta = max - min,
                h, s, v = max;
            v = Math.floor(max / 255 * 100);

            if (max !== 0) {
                s = Math.floor(delta / max * 100);
            } else {
                return [0, 0, 0];
            }
            if (delta === 0) {
                h = 0;
            } else {			
				if (r === max) {
					h = (g - b) / delta;
				} else if (g === max) {
					h = 2 + (b - r) / delta;
				} else {
					h = 4 + (r - g) / delta;
				}
            }
            h = Math.floor(h * 60);
            if (h &lt; 0) {
                h += 360;
            }
            return [h, s, v];
        },
        /**
        Convert an HSV array to a RGB array

            var color=pk.color.hsv2rgb([0,100,100]);
            // color = [255,0,0]

        @method hsv2rgb
        @param hsv {Array} Array of hue, saturation and value components
        @return {Array} Returns array of red, blue and green components
        */
        hsv2rgb: function(hsv) {
			hsv=pk.toArr(hsv);
            var
                r, g, b, i, f, p, q, t, h = hsv[0],
                s = hsv[1],
                v = hsv[2];
            h = Math.max(0, Math.min(360, h));
            s = Math.max(0, Math.min(100, s));
            v = Math.max(0, Math.min(100, v));
            s /= 100;
            v /= 100;
            h = h === 360 ? 0 : h;
            if (s === 0) {
                r = g = b = v;
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }
            h /= 60;
            i = Math.floor(h);
            f = h - i;
            p = v * (1 - s);
            q = v * (1 - s * f);
            t = v * (1 - s * (1 - f));
            switch (i) {
                case 0:
                    r = v;
                    g = t;
                    b = p;
                    break;
                case 1:
                    r = q;
                    g = v;
                    b = p;
                    break;
                case 2:
                    r = p;
                    g = v;
                    b = t;
                    break;
                case 3:
                    r = p;
                    g = q;
                    b = v;
                    break;
                case 4:
                    r = t;
                    g = p;
                    b = v;
                    break;
                case 5:
                    r = v;
                    g = p;
                    b = q;
                    break;
            }
            r = Math.round(r * 255);
            g = Math.round(g * 255);
            b = Math.round(b * 255);
            return [r, g, b];
        },
        /**
        Convert an RGB array to a HSL array

            var color=pk.color.rgb2hsl([255,0,0]);
            // color = [0,100,50]

        @method rgb2hsl
        @param RGB {Array} Array of red, green and blue components
        @return {Array} Returns array of hue, saturation and lightness components
        */		
        rgb2hsl: function(rgb) {
			rgb=pk.toArr(rgb);
            var r = rgb[0],
                g = rgb[1],
                b = rgb[2];
            r /= 255;
            g /= 255;
            b /= 255;
            var max = Math.max(r, g, b),
                min = Math.min(r, g, b);
            var h, s, l = (max + min) / 2;
            if (max === min) {
                h = s = 0; // achromatic
            } else {
                var d = max - min;
                s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r:
                        h = (g - b) / d + (g &lt; b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4;
                        break;
                }
                h /= 6;
            }
            return [h, s, l];
        },
        /**
        Convert an HSL array to a RGB array

            var color=pk.color.hsl2rgb([0,100,50]);
            // color = [255,0,0]

        @method hsl2rgb
        @param HSL {Array} Array of hue, saturation and lightness components
        @return {Array} Returns array of red, green and blue components
        */				
        hsl2rgb: function(hsl) {
			hsl=pk.toArr(hsl);
            var h = hsl[0],
                s = hsl[1],
                l = hsl[2],
                r, g, b;

            function hue2rgb(p, q, t) {
                if (t &lt; 0) {
                    t += 1;
                }
                if (t &gt; 1) {
                    t -= 1;
                }
                if (t &lt; 1 / 6) {
                    return p + (q - p) * 6 * t;
                }
                if (t &lt; 1 / 2) {
                    return q;
                }
                if (t &lt; 2 / 3) {
                    return p + (q - p) * (2 / 3 - t) * 6;
                }
                return p;
            }
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {

                var q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }

            return [r * 255, g * 255, b * 255];
        },
        /**
        Convert a HEX color string to a HSL array

            var color=pk.color.hex2hsl(&#x27;#FF0000&#x27;);
            // color = [0,100,50]

        @method hex2hsl
        @param hex {String} HEX color string
        @return {Array} Returns array of hue, saturation and lightness components
        */
        hex2hsl: function(hex) {
            return this.rgb2hsl(this.hex2rgb(hex));
        },
        /**
        Convert an HSL array to a HEX color string

            var color=pk.color.hsl2hex([0,100,50]);
            // color = &#x27;#FF0000&#x27;

        @method hsl2hex
        @param hsl {Array} Array of hue, saturation and lightness components
        @return {String} Returns HEX color string
        */
        hsl2hex: function(hsl) {
            return this.rgb2hex(this.hsl2rgb(pk.toArr(hsl)));
        },
		
        /**
        Convert an HSV array to HSL array

            var color=pk.color.hsv2hsl([0,100,100]);
            // color = [0,100,50]

        @method hsv2hsl
        @param hsv {Array} Array of hue, saturation and value components
        @return {Array} Returns array of hue, saturation and lightness components
        */
        hsv2hsl: function(hsv) {
            return this.rgb2hsl(this.hsv2rgb(pk.toArr(hsv)));
        },
			
        /**
        Convert an HSL array to HSV array

            var color=pk.color.hsl2hsv([0,100,50]);
            // color = [0,100,100]

        @method hsl2hsv
        @param hsl {Array} Array of hue, saturation and lightness components
        @return {Array} Returns array of hue, saturation and value components
        */
        hsl2hsv: function(hsl) {
            return this.rgb2hsv(this.hsl2rgb(pk.toArr(hsl)));
        },			
		
        /**
        Convert a HEX color string to a HSV array

            var color=pk.color.hex2hsv(&#x27;#FF0000&#x27;);
            // color = [0,100,100]

        @method hex2hsv
        @param hex {String} HEX color string
        @return {Array} Returns array of hue, saturation and value components
        */
        hex2hsv: function(hex) {
            return this.rgb2hsv(this.hex2rgb(hex));
        },
        /**
        Convert an HSV array to a HEX color string

            var color=pk.color.hsv2hex([0,100,100]);
            // color = &#x27;#FF0000&#x27;

        @method hsv2hex
        @param hsv {Array} Array of hue, saturation and value components
        @return {String} Returns HEX color string
        */
        hsv2hex: function(hsv) {
            return this.rgb2hex(this.hsv2rgb(pk.toArr(hsv)));
        },
        /**
        Generate a series of color biased (high saturation/lightness) randomized HEX color strings

            var palette=pk.color.random(5);
            // palette = [&quot;#efa6a8&quot;, &quot;#91abb&quot;, &quot;#ebac2c&quot;, &quot;#2b561&quot;, &quot;#7b4b51&quot;]

        @method random
        @param count {Number} Number of random colors to generate
		@param [hex1] {String} HEX color string to set band to generate random color(s)
		@param [hex2] {String} HEX color string to set band to generate random color(s)
        @return {Array} Returns Array of HEX color strings
        */
        random: function(count, hex1, hex2) {
            var palette = [],
                i, h, s, v
            count = typeof count !== &#x27;number&#x27; ? 1 : count; 
			
			if(hex1 &amp;&amp; hex2){
			 var hsv1=this.hex2hsv(hex1),
				 hsv2=this.hex2hsv(hex2);
				 h=pk.getRand(Math.min.apply(Math, [hsv1[0], hsv2[0]]), Math.max.apply(Math, [hsv1[0], hsv2[0]]));
				 s=pk.getRand(Math.min.apply(Math, [hsv1[1], hsv2[1]]), Math.max.apply(Math, [hsv1[1], hsv2[1]]));
				 v=pk.getRand(Math.min.apply(Math, [hsv1[2], hsv2[2]]), Math.max.apply(Math, [hsv1[2], hsv2[2]]));
			}else{
				h=pk.getRand(0,360);
				s=100;
				v=pk.getRand(75,100);
			}
			
            for (i = 0; i &lt; count; i += 1) {
            //    palette.push(&#x27;#&#x27; + Math.floor(Math.random() * 16777215).toString(16));
				palette.push(this.hsv2hex([h,s,v]));
            }
            return palette;
        }, 
        /**
        Generate (palette of) complementary color(s) from passed HEX color string
		
            var palette=pk.color.complement(&#x27;#FF0000&#x27;, &#x27;split&#x27;);
            // palette = [&quot;#80ff00&quot;, &quot;#00ffff&quot;, &quot;#8000ff&quot;]
			
            var palette=pk.color.complement(&#x27;#FF0000&#x27;, &#x27;double&#x27;);
            // palette = [&quot;#80ff00&quot;, &quot;#00ff40&quot;, &quot;#00ffff&quot;, &quot;#0040ff&quot;, &quot;#8000ff&quot;] 			
		
        @method complement
        @param hex {String} HEX color string
        @param [type] {String} Type of complementary palette to create, defaults to single complementary color, can be &#x60;split&#x60; or &#x60;double&#x60;
        @return {Array} Returns array of HEX color strings
        */
        complement: function(hex, type) {
            var count = 1,
                rotation = 180,
                scope = 0;
            switch (type) {
                case &quot;split&quot;:
                    count = 3;
                    rotation = 180;
                    scope = 180;
                    break;
                case &quot;double&quot;:
                    count = 5;
                    rotation = 180;
                    scope = 180;
                    break;
            }			
            return this.algorithmic({
				hex:hex,
				count:count,
				scope:scope,
				rotation:180
			});
        },
        /**
        Generate triadic color palette
		
            var palette=pk.color.triadic(&#x27;#FF0000&#x27;);
            // palette = [&quot;#ff0000&quot;, &quot;#00ff00&quot;, &quot;#0000ff&quot;] 
				
		
        @method triadic
        @param hex {String} HEX color string
        @return {Array} Returns array of HEX color strings
        */
        triadic: function(hex) {
            return this.algorithmic({hex:hex});
        },
        /**
        Generate tetradic color palette
		
            var palette=pk.color.triadic(&#x27;#FF0000&#x27;);
            // palette = [&quot;#ff0000&quot;, &quot;#80ff00&quot;, &quot;#00ffff&quot;, &quot;#8000ff&quot;] 
			
        @method tetradic
        @param hex {String} HEX color string
        @return {Array} Returns array of HEX color strings
        */
        tetradic: function(hex) {
            return this.algorithmic({
				hex:hex,
				count:4
			});
        },
        /**
        Generate pentadic color palette
		
            var palette=pk.color.triadic(&#x27;#FF0000&#x27;);
            // palette = [&quot;#ff0000&quot;, &quot;#ccff00&quot;, &quot;#00ff66&quot;, &quot;#0066ff&quot;, &quot;#cc00ff&quot;] 
			
        @method pentadic
        @param hex {String} HEX color string
        @return {Array} Returns array of HEX color strings
        */
        pentadic: function(hex) {
            return this.algorithmic({
				hex:hex,
				count:5
			});
        },
        degrees: function(degrees, offset) {
            degrees += offset;
            if (degrees &gt; 360) { 
                degrees -= 360;
            } else if (degrees &lt; 0) {
                degrees += 360;
            }
            return degrees;
        },
        /**
        Generate a color from a percentage point between two colors
		
            var color=pk.color.percentage(0.5);
            // color = &quot;#f2e600&quot;;
			
        @method percentage
        @param perc {Number} Percentage between first and second colors to generate color point from expressed as value between zero and one
		@param [hex1=#ff0000] {String} Starting color HEX value defaults to &#x60;#ff0000&#x60; red so 0% is red
		@param [hex2=#27ae62] {String} Starting color HEX value defaults to &#x60;#1ae500&#x60; green so 100% is green
        @return {String} Returns resulting HEX color
        */		
		percentage:function(perc, hex1, hex2){
			hex1=hex1 || &#x27;#ff0000&#x27;;
			hex2=hex2 || &#x27;#27ae62&#x27;;	
			var hsv1=pk.color.hex2hsv(hex1),
				hsv2=pk.color.hex2hsv(hex2);				
			return pk.color.hsv2hex([Math.round(hsv1[0]+perc*(hsv2[0]-hsv1[0])),Math.round(hsv1[1]+perc*(hsv2[1]-hsv1[1])),Math.round(hsv1[2]+perc*(hsv2[2]-hsv1[2]))]);
		},		
		/**
        Scale either hue, saturation or value of a color by a percentage amount
		
            var scale=pk.scale.percentage(0.5);
            // color = &quot;#f2e600&quot;;
			
        @method scale
		@param hex {String} HEX color string
        @param perc {Number} Percentage to adjust color by
		@param [type=hue] {String} String, scale to adjust, either &#x60;hue&#x60;, &#x60;saturation&#x60; or &#x60;value&#x60;
		@param [abs] {Boolean} Define percentage as absolute value from base to max, defaults to relative value between current and max
        @return {String} Returns resulting HEX color
        */		
		scale:function(hex, perc, type, abs){ 
			type=type||&#x27;hue&#x27;;			
			
			var hsv=this.hex2hsv(hex),
				adj=type===&#x27;hue&#x27; ? hsv[0] : type===&#x27;saturation&#x27; ? hsv[1] : hsv[2];
			perc = Math.abs(perc) &gt; 1 ? perc/100 : perc;
			perc = abs===true ? perc*100 : adj+((type===&#x27;hue&#x27; ? 360 : 100)-adj)*perc;		
			return this.hsv2hex([type===&quot;hue&quot; ? adj : hsv[0], type===&quot;saturation&quot; ? perc : hsv[1], type===&quot;value&quot; ? perc : hsv[2]]);  
		},	
		/**
        Lighten a color by a percentage amount
		
            var color=pk.color.lighten(&#x27;#840000&#x27;, 70);
            // color = &quot;#da0000&quot;;
			
        @method lighten
		@param hex {String} HEX color string
        @param perc {Number} Percentage to lighten color by
		@param [abs=lightness] {Boolean} Define percentage lightness as absolute value, defaults to relative
        @return {String} Returns resulting HEX color
        */		
		lighten:function(hex, perc, abs){ 
			perc = perc &gt; 0 ? perc : -1*perc;
			return this.scale(hex, perc, &#x27;value&#x27;, abs); 
		},
		/**
        Darken a color by a percentage amount
		
            var color=pk.color.darken(&#x27;#840000&#x27;, 70);
            // color = &quot;#da0000&quot;;
			
        @method darken
		@param hex {String} HEX color string
        @param perc {Number} Percentage to darken color by
		@param [abs=lightness] {Boolean} Define percentage lightness as absolute value, defaults to relative
        @return {String} Returns resulting HEX color
        */		
		darken:function(hex, perc, abs){  
			perc = perc &lt; 0 ? perc : -1*perc;
			return this.scale(hex, perc, &#x27;value&#x27;, abs); 
		},	
		/**
        Saturate a color by a percentage amount
		
            var color=pk.color.saturate(&#x27;#840000&#x27;, 70);
            // color = &quot;#820000&quot;;
			
        @method saturate
		@param hex {String} HEX color string
        @param perc {Number} Percentage to saturate color by
		@param [abs=lightness] {Boolean} Define percentage saturation as absolute value, defaults to relative
        @return {String} Returns resulting HEX color
        */		
		saturate:function(hex, perc, abs){ 
			perc = perc &gt; 0 ? perc : -1*perc;
			return this.scale(hex, perc, &#x27;saturation&#x27;, abs); 
		},	
		/**
        Desaturate a color by a percentage amount
		
            var color=pk.color.desaturate(&#x27;#840000&#x27;, 70);
            // color = &quot;#820000&quot;;
			
        @method saturate
		@param hex {String} HEX color string
        @param perc {Number} Percentage to saturate color by
		@param [abs=lightness] {Boolean} Define percentage desaturation as absolute value, defaults to relative
        @return {String} Returns resulting HEX color
        */		
		desaturate:function(hex, perc, abs){ 
			perc = perc &gt; 0 ? perc : -1*perc;
			return this.scale(hex, perc, &#x27;saturation&#x27;, abs); 
		},		
        /**
        Generate algorithmic color palette
		
            var palette=pk.color.algorithmic ({hex:&#x27;#FF0000&#x27;});
            // palette = [&quot;#ff0000&quot;, &quot;#00ff00&quot;, &quot;#0000ff&quot;] 		
		
            var palette=pk.color.algorithmic ({hex:&#x27;#FF0000&#x27;, count: 5});
            // palette = [&quot;#ff0000&quot;, &quot;#ccff00&quot;, &quot;#00ff66&quot;, &quot;#0066ff&quot;, &quot;#cc00ff&quot;]  			
		
            var palette=pk.color.algorithmic ({hex:&#x27;#FF0000&#x27;, scope: 100, count:4});
            // palette = [&quot;#ff00d4&quot;, &quot;#ff0047&quot;, &quot;#ff4700&quot;, &quot;#ffd500&quot;]

            var palette=pk.color.algorithmic ({hex:&#x27;#FF0000&#x27;, type:&#x27;saturation&#x27;, scope:50});
            // palette = [&quot;#ffffff&quot;, &quot;#ffbfbf&quot;, &quot;#ff8080&quot;]
			
        @method algorithmic
		@param options {Object} Algorithmic color transformation options
        @param options.hex {String} HEX color string
        @param [options.count=3] {Number} Number of colors to produce
        @param [options.type=hue] {String} Component to calculate on, either &#x60;hue&#x60;, &#x60;saturation&#x60; or &#x60;value&#x60;
        @param [options.scope=360] {Number} Number of degrees of rotation to consider
        @param [options.rotation=0] {Number} Number of degrees of rotation to calculate from
        @return {Array} Returns array of HEX color strings
        */
        // pick a point on the wheel, the number of degrees either side to cover and the split
        algorithmic: function(opt) {
			if(!opt.hex){return;}
			var hex=opt.hex,
				count = typeof opt.count === &#x27;undefined&#x27; ? 3: opt.count,
				type = typeof opt.type === &#x27;undefined&#x27; ? &#x27;hue&#x27; : opt.type,
				scope = typeof opt.scope === &#x27;undefined&#x27; ? 360 : opt.scope,
				rotation = typeof opt.rotation === &#x27;undefined&#x27; ? 0 : opt.rotation,
                hsv = this.hex2hsv(hex),
                h = hsv[0],
                s = hsv[1],
                v = hsv[2],
                origin, steps, palette = [],
                offset, i;
            // if scope is 360, the start and end point are the same color, so should be avoided, otherwise enlargen the steps
            steps = (type === &quot;hue&quot; &amp;&amp; (scope === 360 || scope === 0)) ? scope / count : scope / (count - 1);
            // if scope is 360, start on the current color
            origin = (scope === 360) ? h : this.degrees(this.degrees(h, rotation), -1 * scope / 2);
            for (i = 0; i &lt; count; i += 1) {
                offset = steps * i;
                switch (type) {
                    case &quot;hue&quot;:
                        palette.push(this.hsv2hex([this.degrees(origin, offset, 360) === 360 ? 0 : this.degrees(origin, offset, 360), s, v]));
                        break;
                    case &quot;saturation&quot;:
                        palette.push(this.hsv2hex([h, offset, v]));
                        break;
                    case &quot;value&quot;:
                    case &quot;lightness&quot;:
                    case &quot;brightness&quot;:
                        palette.push(this.hsv2hex([h, s, offset]));
                        break;
                }
            }
            return palette; 
        }
    };
    return pk;
})(pk);

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
