/**
 * pocketknife
 * @version v0.0.1129
 * @link https://github.com/sw4/pocketknife
 * @copyright (c)2014 Pocketknife Ltd.
 * @license CC BY-NC-SA (https://github.com/sw4/pocketknife/blob/master/LICENSE-CC-NC-SA.md)
 */
var pk = pk || {};
/**
Create a new accordian component from an unordered list element `<ul>` with the below structure:

HTML:

	<ul id='accordian'>
        <li>
            <h3 class='pk-content-header'>Content header</h3>
            <div class='pk-content'>
				Content to collapse
			</div>
        </li>
        <li>
            <h3 class='pk-content-header'>Content header</h3>
            <div class='pk-content'>
				Content to collapse
			</div>
        </li>
        <li>
            <h3 class='pk-content-header'>Content header</h3>
            <div class='pk-content'>
				Content to collapse
			</div>
        </li>		
    </ul>

Javascript:

	pk.accordian({
		element: document.getElementById('accordian'),
		animate: true,
		multiple: true
	});		
		
@class pk.accordian
@constructor
@param options {Object}
@param options.element {Object} DOM element to convert to component
@param [options.animate=true] {Boolean} Animate expand/collapse actions
@param [options.multiple=true] {Boolean} Allow multiple sections to be expanded simultaneously
@return Object {Object} Consisting of original DOM element (item `0`)
@chainable
*/

(function(pk) {
    pk.accordian = function(opt) {
        var el = opt.element,
            anim = opt.animate === false ? false : opt.animate || true,
            multiple = opt.multiple === false ? false : opt.multiple || true;

		pk.addClass(el, 'pk-accordian');
		
        function animHeight(tEl) {
            tEl.style.height = 'auto';
            var h = pk.layout(tEl).height;
            tEl.style.height = '0';
            setTimeout(function() {
                tEl.style.height = h + 'px';
            }, 10);
        }

        function doLayout(tEl) {
            for (var a = 0; a < el.children.length; a++) {
                // loop through each....

                var content = el.children[a].children[1];
                // if multiple set to false and node passed, hide all other nodes
                if (tEl && el.children[a] !== tEl && multiple === false) {
                    pk.removeClass(el.children[a], 'pk-show');
                }
                if (pk.hasClass(el.children[a], 'pk-show')) {
                    // show...if not already shown
                    if (parseInt(content.style.height, 0) === 0 || !content.style.height) {
                        if (anim) {
                            animHeight(content);
                        } else {
                            content.style.height = 'auto';
                        }
                    }
                } else {
                    // hide
                    content.style.height = '0';
                }
            }
        }
        pk.bindEvent('click', el, function(e) {
            if (!pk.hasClass(e.target, 'pk-content-header')) {
                return;
            }
            pk.toggleClass(e.target.parentNode, 'pk-show');
            doLayout(e.target.parentNode);
        });
        doLayout();
        return {
            0: el
        };
    };
    return pk;
})(pk);

var pk = pk || {};
/**
Create a new carousel component from an unordered list element `<ul>`

HTML:

    <ul id='carousel'>
        <li>Slide 1</li>
        <li>Slide 2</li>
        <li>Slide 3</li>
    </ul>

Javascript:
	
	pk.carousel({
		element: document.getElementById('carousel'),
		delay:5000
	});

@class pk.carousel
@constructor
@param options {Object}
@param options.element {Object} DOM element to convert to component
@param [options.value=0] {Number} Starting item index
@param [options.tabindex=0] {Number} Tabindex of component, defaults to the attribute value set on the passed element, or `0`
@param [options.delay=4000] {Number} Delay in `ms` between item changes
@return Object {Object} Consisting of original DOM element (item `0`) and class methods (see below)
@chainable
*/
(function(pk) {
    pk.carousel = function(opt) {
        var el = opt.element,
            options = opt.options || [],
            value = opt.value || 0,
            delay = opt.delay || 4000,
            timer = true,
            inputTabIndex = opt.tabindex || el.getAttribute('tabindex') || 0;

        if (options.length === 0 && el.nodeName === "UL") {
            for (var i = 0; i < el.children.length; i++) {
                options.push(el.children[i].innerHTML);
            }
        }
        var tpl = "<div class='pk-carousel' tabindex='" + inputTabIndex + "'><ul>",
            navEl = [],
            optionEl = [];
        for (var o = 0; o < options.length; o++) {
            optionEl.push(pk.createEl("<li class='pk-option'>" + options[o] + "</li>"));
            navEl.push(pk.createEl("<span class='pk-nav-item' data-nav='=" + o + "'>" + o + "</span>"));
        }
        tpl += "</ul><span class='pk-nav-prev' data-nav='-1'></span><span data-nav='+1' class='pk-nav-next'></span></div>";

        el.innerHTML = '';
        el = pk.replaceEl(el, tpl);
        for (o = 0; o < options.length; o++) {
            el.children[0].appendChild(optionEl[o]);
            el.appendChild(navEl[o]);
        }

        function clickHandler(e) {
            obj.val(pk.attribute(e.target, 'data-nav'));
        }
        for (var c in el.children) {
            if (pk.attribute(el.children[c], 'data-nav')) {
                pk.bindEvent('click', el.children[c], clickHandler);
            }
        }

        pk.bindEvent("mousewheel", el, function(e) {
            pk.preventBubble(e);
            obj.val((e.wheelDelta < 0 || e.detail > 0) ? '-1' : '+1');
        });

        pk.bindEvent('keydown', el, function(e) {
            if (document.activeElement !== el) {
                return;
            }
            switch (e.keyCode) {
                case 34: //page down
                case 40: //down cursor
                case 37: //left cursor
                    obj.val('-1');
                    pk.preventBubble(e);
                    break;
                case 33: //page up
                case 32: //spacebar				
                case 38: //up cursor
                case 39: //right cursor
                    obj.val('+1');
                    pk.preventBubble(e);
                    break;
                case 36: //home
                    obj.val(0);
                    pk.preventBubble(e);
                    break;
                case 35: //end
                    obj.val(options.length - 1);
                    pk.preventBubble(e);
                    break;
            }
        });
        var oldVal;
        /**
        Gets or sets control item
        @method val
        @param [value] {Number} Item index to set
        @return {Number} Returns current item index
        */
        var obj = {
            0: el,
            val: function(val) {
                val = val.toString();
                if (val === undefined) {
                    return value;
                }
                var inClass = '',
                    outClass = '';
                if (val.indexOf("-") !== -1) {
                    value = value - parseInt(val.replace('-', ''), 0) < 0 ? options.length - 1 : --value;
                    inClass = 'left';
                    outClass = 'right';
                } else if (val.indexOf("+") !== -1) {
                    value = value + parseInt(val.replace('+', ''), 0) > options.length - 1 ? 0 : ++value;
                    inClass = 'right';
                    outClass = 'left';
                } else {
                    value = parseInt(val.replace('=', ''), 0);
                    value = value < 0 ? 0 : value > options.length - 1 ? options.length - 1 : value;
                    if (oldVal !== undefined && value > oldVal) {
                        inClass = 'right';
                        outClass = 'left';
                    } else {
                        inClass = 'left';
                        outClass = 'right';
                    }
                }
                for (o = 0; o < options.length; o++) {
                    if (oldVal !== undefined && oldVal === o) {
                        pk.addClass(optionEl[o], 'pk-carousel-out-' + outClass);
                    } else if (oldVal !== undefined) {
                        pk.removeClass(optionEl[o], 'pk-carousel-out-left');
                        pk.removeClass(optionEl[o], 'pk-carousel-out-right');
                    }
                    if (parseInt(o, 0) === value) {
                        // add the selected class to the current iteration					
                        pk.addClass(optionEl[o], 'pk-selected');
                        pk.addClass(navEl[o], 'pk-selected');
                        if (oldVal !== undefined) {
                            pk.addClass(optionEl[o], 'pk-carousel-in-' + inClass);
                        }
                    } else {
                        pk.removeClass(optionEl[o], 'pk-selected');
                        pk.removeClass(optionEl[o], 'pk-carousel-in-right');
                        pk.removeClass(optionEl[o], 'pk-carousel-in-left');
                        pk.removeClass(navEl[o], 'pk-selected');
                    }
                }
                oldVal = value;
                timer = false;
                return value;
            }
        };
        obj.val(value);

        if (delay) {
            setInterval(function() {
                if (timer) {
                    obj.val('+1');
                }
                timer = true;
            }, delay);
        }

        return obj;
    };
    return pk;
})(pk);

var pk = pk || {};
/**
Create a new chart component

HTML

	<div id='chart'></div>

Javascript:

	pk.chart({
		element: document.getElementById('chart'),
		type:'pie',
		data: [
			{category:"cat",series1:8, series2:2},
			{category:"pig",series1:2, series2:6},
			{category:"cow",series1:9, series2:9},
			{category:"bird",series1:5, series2:2},
			{category:"dog",series1:2, series2:7},
			{category:"emu",series1:6, series2:3},
			{category:"hamster",series1:2, series2:3}
		],
		center:20,
		legend:true,
		axis:{
			x:'category'
		},
		series: ['series1', 'series2']
	});
	
@class pk.chart
@constructor 
@beta
@param type {String} Chart type to create, `pi`, or `line`
@param [center=0] {Number} If chart type `pie`, the inner radius to create a donut chart, expressed as a percentage of diameter (`2*r`)
@param data {Object} Object array of data to use for the chart
@param axis {Object} Object keys in data to use for `x` and `y` axes
@param axis.x {String} Object keys in data to use for `x` axis
@param [axis.y] {String} Object keys in data to use for `y` axis, marked optional as not required for `pie` charts
@param series {Array} Object keys in data used for series designation - only an Array for `pie` charts
@param series {String} Object key in data used for series designation - only a String for `line` charts
@param [margin] {Object} Object of `top`, `right`, `left` and `bottom` margin amounts in pixels. Defaults to `20,20,50,20`
@param [colors] {Object} Object key value pairs where the key is a series name, the value is the value to use
@param [points=5] {String} Object key in data used to calculate proportionate point size, or number
@param [legend] {Function} Custom function responsible for building chart legend, defaults to stock constructor if not passed

@chainable
*/
(function(pk) {
    pk.chart = function(opt) {
        var el=pk.replaceEl(opt.element, "<div class='pk-chart'></div>"),
			l=pk.layout(el),
			svgEl=pk.createEl("<svg />"),
			data=opt.data || [],
			series=opt.series,
			seriesMeta={},
			axesMeta={x:{data:[], sum:0},y:{data:[], sum:0}, r:{data:[]}},
			axis=opt.axis,
			d = l.height > l.width ? l.width : l.height,
			stroke= opt.center ? (d/2)-(d*((opt.center/2) /100)) : d/2,
			colors=opt.colors || {},
			type=opt.type,
			margin={
				top:opt.margin && opt.margin.top || 20,
				right:opt.margin && opt.margin.right || 20,
				bottom:opt.margin && opt.margin.bottom || 50,
				left:opt.margin && opt.margin.left || 20
			},
			legendEl=pk.createEl("<div class='pk-legend'></div>"), 
			legend=typeof opt.legend==='function'?opt.legend:!opt.legend ? false : function(mInf){

				switch(type){
					case "pie":
						pk.addClass(legendEl, 'pk-table');
						if(series.length > 1){
							var hTpl="<div class='pk-row pk-legend-header'><div class='pk-legend-category pk-cell'></div>";
							for(var e=0;e<series.length;e++){
								hTpl+="<div class='pk-cell pk-legend-series'>"+series[e]+"</div>";
							}
							legendEl.innerHTML+=hTpl+"</div>";
						}
						
						for(var c in mInf){
							var sI=0;
							var lTpl="<div class='pk-row pk-legend-entry'>";					
							if(series.length > 1){
								lTpl+="<div class='pk-cell pk-legend-category'>"+c+":</div>";
							}
							for(var s in mInf[c]){ 
								lTpl+="<div class='pk-cell pk-legend-series' data-rel='"+('rel'+s+c).replace(' ' ,'')+"'><span class='pk-indicator' style='border-color:"+mInf[c][s].color+";background-color:"+mInf[c][s].color+";' data-rel='"+('rel'+s).replace(' ' ,'')+"'></span>"+mInf[c][s].percentage+"%"+"</div>";
								sI++;
							}   
							if(series.length === 1){
								lTpl+="<div class='pk-cell pk-legend-category'>"+c+"</div>";
							}
							lTpl+="</div>"; 
							legendEl.innerHTML+=lTpl;	 
						}	
						pk.addClass(el, (l.height >= l.width ? "pk-legend-bottom" : "pk-legend-right")); 
		
					break;
					case "scatter":
					case "line":
					case "area":
						for(s in mInf){
							legendEl.innerHTML+= "<div class='pk-legend-series' data-rel='"+('rel'+s).replace(' ' ,'')+"'><span class='pk-indicator' style='border-color:"+colors[s]+";background-color:"+colors[s]+";' data-rel='"+('rel'+s).replace(' ' ,'')+"'></span>"+s+"</div>";						
						}					
					break;
				}
			};		
			
		margin.x=margin.left+margin.right;
		margin.y=margin.top+margin.bottom;
		
		if(data.length===0){return;}	
		
		pk.addClass(el, 'pk-'+type+'-chart');
			
		data.sort(function(a, b){
		 return a[axis.x]-b[axis.x];
		});	
		
		pk.bindEvent('mouseover', el, function(e){		
			if(pk.attribute(e.target, 'data-rel')){
				var hIt=pk.findEl(el, {attribute:{name:'data-rel', value:pk.attribute(e.target, 'data-rel')}});	
				for(h=0;h<hIt.length;h++){							
					pk.addClass(hIt[h], 'selected'); 
				}	
			}				
		});			 	
		pk.bindEvent('mouseout', el, function(e){
			if(pk.attribute(e.target, 'data-rel')){
				var hIt=pk.findEl(el, {attribute:{name:'data-rel', value:pk.attribute(e.target, 'data-rel')}});	
				for(h=0;h<hIt.length;h++){							
					pk.removeClass(hIt[h], 'selected'); 
				}	
			}
		});		
		
		pk.attribute(svgEl, {height:type==='pie' ? d : l.height, width:type==='pie' ? d : l.width});
		
		/*
		START PIE CHART
		*/
		switch(type){
		
			case "pie":
			
				for(var s in series){
						seriesMeta[series[s]]={};
						seriesMeta[series[s]].data=[];		
						seriesMeta[series[s]].sum=0; 
						for(var i=0;i<data.length;i++){			
							seriesMeta[series[s]].data.push(data[i][series[s]]);
							seriesMeta[series[s]].sum+=Math.abs(parseInt(data[i][series[s]],0));
							if(!colors[data[i][axis.x]]){
								colors[data[i][axis.x]]=pk.color.percentage(i/data.length); 
							}
						}			
						seriesMeta[series[s]].min=Math.min.apply(Math, seriesMeta[series[s]].data);
						seriesMeta[series[s]].max=Math.max.apply(Math, seriesMeta[series[s]].data);
						seriesMeta[series[s]].range=Math.abs(seriesMeta[series[s]].max-seriesMeta[series[s]].min);			
				}
				var sIndex=0;
				var metaObj={};			
			
				for(s in seriesMeta){
					var ttlArc=0;
					for(var i=0;i<seriesMeta[s].data.length;i++){	
					
						var pathCol=pk.color.darken(colors[data[i][axis.x]], sIndex*(50/series.length));
						var pathEl=pk.createEl("<path x='"+d/2+"' y='"+d/2+"' fill='none' stroke='"+pathCol+"' d='' stroke-width='"+(stroke/series.length+1)+"'/>");
						
						svgEl.appendChild(pathEl);
						var arc = Math.round((Math.abs(seriesMeta[s].data[i])/seriesMeta[s].sum)*360);
						var r=((d-stroke/2)/2) - (stroke/2*sIndex);
						r = series.length>1 ? r : (d/2)-stroke/2;
						pk.attribute(pathEl, {'d':pk.svg.arcPath(d/2, d/2,  r, ttlArc, ttlArc+arc), 'data-rel':('rel'+s+data[i][axis.x]).replace(' ' ,'')});  
						if(typeof legend === 'function'){
							if(!metaObj[data[i][axis.x]]){
								metaObj[data[i][axis.x]]={};
							}
							if(!metaObj[data[i][axis.x]][s]){
								metaObj[data[i][axis.x]][s]={
									value:data[i][s],
									percentage:Math.round(arc*100/360),
									color:pathCol,
									relEl:pathEl
								};
							}
						}					
						
						ttlArc+=arc;
					}	
					sIndex++;			
				}
				legend(metaObj); 
			break;

			case "scatter":
			case "line":
			case "area":
				for(var i=0;i<data.length;i++){		
					seriesMeta[data[i][series]] = seriesMeta[data[i][series]] || {
						x:{
							data:[],
							sum:0
						},
						y:{
							data:[],
							sum:0
						},
						r:{
							data:[]
						}		
					};
					seriesMeta[data[i][series]].x.data.push(data[i][axis.x]);				
					seriesMeta[data[i][series]].x.sum+=data[i][axis.x];				
					seriesMeta[data[i][series]].y.data.push(data[i][axis.y]);
					seriesMeta[data[i][series]].y.sum+=data[i][axis.y];
					seriesMeta[data[i][series]].y.min = !seriesMeta[data[i][series]].y.min || data[i][axis.x] < seriesMeta[data[i][series]].y.min ? data[i][axis.x] : seriesMeta[data[i][series]].y.min;
					seriesMeta[data[i][series]].y.max = !seriesMeta[data[i][series]].y.max || data[i][axis.x] > seriesMeta[data[i][series]].y.max ? data[i][axis.x] : seriesMeta[data[i][series]].y.max;
					seriesMeta[data[i][series]].y.range = Math.abs(seriesMeta[data[i][series]].y.max-seriesMeta[data[i][series]].y.min);
					seriesMeta[data[i][series]].x.min = !seriesMeta[data[i][series]].x.min || data[i][axis.x] < seriesMeta[data[i][series]].x.min ? data[i][axis.x] : seriesMeta[data[i][series]].x.min;
					seriesMeta[data[i][series]].x.max = !seriesMeta[data[i][series]].x.max || data[i][axis.x] > seriesMeta[data[i][series]].x.max ? data[i][axis.x] : seriesMeta[data[i][series]].x.max;
					seriesMeta[data[i][series]].x.range = Math.abs(seriesMeta[data[i][series]].x.max-seriesMeta[data[i][series]].x.min);
					

					if(opt.points){seriesMeta[data[i][series]].r.data.push(data[i][opt.points]);}


					axesMeta.x.data.push(data[i][axis.x]);
					axesMeta.x.sum+=data[i][axis.x];
					axesMeta.y.data.push(data[i][axis.y]);
					axesMeta.y.sum+=data[i][axis.y];
					
					
					if(opt.points){axesMeta.r.data.push(data[i][opt.points]);}
					
				}
				axesMeta.x.min=Math.min.apply(Math, axesMeta.x.data);
				axesMeta.x.min = axesMeta.x.min <= 0 ? axesMeta.x.min : 0;
				axesMeta.x.max=Math.max.apply(Math, axesMeta.x.data);
				axesMeta.x.range = Math.abs(axesMeta.x.max-axesMeta.x.min);
				axesMeta.y.min=Math.min.apply(Math, axesMeta.y.data);
				axesMeta.y.min = axesMeta.y.min <= 0 ? axesMeta.y.min : 0; 
				axesMeta.y.max=Math.max.apply(Math, axesMeta.y.data);
				axesMeta.y.range = Math.abs(axesMeta.y.max-axesMeta.y.min);
				
				if(opt.points){axesMeta.r.range = Math.abs(Math.max.apply(Math, axesMeta.r.data)-Math.min.apply(Math, axesMeta.r.data));}

				// Get range pixel amounts
				yUnit= ((l.height-margin.y)/axesMeta.y.range);
				xUnit= ((l.width-margin.x)/(axesMeta.x.range));
				
				
				// Draw AXES
				// Series of .5 pt adjustments to create crisp edges in IE
				var svgTpl="<g class='pk-axes'>\
					<g class='pk-yAxis' transform='translate("+(margin.left-.5)+","+margin.top+")'>\
						<line y2='"+(l.height-margin.y)+"'></line>";
					for(var t=0;t<=axesMeta.y.range;t++){
						svgTpl+="<g class='tick' transform='translate(-5,"+(Math.floor(t*yUnit)+0.5)+")'>\
							<line x2='5'></line>";  
							if(t<axesMeta.y.range){svgTpl+="<line class='pk-tick-line' x1='6' x2='"+(5+l.width-margin.x)+"'></line>";}
							svgTpl+="<text x='-10' y='4' text-anchor='start'>"+((axesMeta.y.range+axesMeta.y.min)-t)+"</text>\
						</g>";				 	
					}
					svgTpl+="</g>\
					<g class='pk-xAxis' transform='translate("+margin.left+","+(l.height-margin.bottom+.5)+")'>\
						<line x2='"+(l.width-margin.x)+"'></line>";
						
		 
					for(t=0;t<=axesMeta.x.range;t++){
						svgTpl+="<g class='tick' transform='translate("+(Math.floor(t*xUnit)+0.5)+", 0)'>\
							<line y2='5'></line>";
							if(t>0){svgTpl+="<line class='pk-tick-line' y2='"+(-1*(l.height-margin.y-1))+"'></line>";}							
							svgTpl+="<text y='17' y='4' text-anchor='middle'>"+(t+axesMeta.x.min)+"</text>\
						</g>";					
					}	
					svgTpl+="</g>\
				</g>";
				svgEl.appendChild(pk.createEl(svgTpl));
				
				var groupEl=pk.createEl("<g class='pk-series'></g>");
				svgEl.appendChild(groupEl);
				/*
				Draw Series
				*/
				var sIndex=0;
				for(var s in seriesMeta){	
					sIndex++;
					
					if(!colors[s]){
						colors[s]=pk.color.random();  
					}
					
					var seriesEl=pk.createEl("<g class='pk-series-"+sIndex+"' />");
					var sPath='', aPath='';
					for(i=0;i<seriesMeta[s].x.data.length;i++){			
						if(i==0){
							sPath+="M";
						}else{
							sPath+=" L "; 
						}
						var pxX=Math.round(margin.left + (xUnit * (seriesMeta[s].x.data[i]-axesMeta.x.min))),
							pxY=Math.round(l.height-(margin.bottom + (yUnit * (seriesMeta[s].y.data[i]-axesMeta.y.min))));
						sPath+=pxX + " " +pxY;
						
						if(type==='area'){
							if(i==0){
								aPath+="M"+pxX + " " +(l.height-margin.bottom);
							}
							aPath+=" L "+pxX + " " +pxY;
							if(i==seriesMeta[s].x.data.length-1){					
								aPath+=" L "+pxX + " " +(l.height-margin.bottom);
							}
						}
						var r=seriesMeta[s].r.data[i] ? (seriesMeta[s].r.data[i]*20 / axesMeta.r.range)  : typeof opt.points === 'number' ? opt.points : 5;
						
						seriesEl.appendChild(pk.createEl("<circle cx='"+pxX+"' cy='"+pxY+"' r='"+r+"' fill='"+colors[s]+"' stroke='"+colors[s]+"' data-rel='rel"+s.replace(' ','')+"' />")); 
					} 
					if(type!='scatter'){ 
						seriesEl.insertBefore(pk.createEl("<path class='pk-line' fill='none' stroke='"+colors[s]+"' d='"+sPath.trim()+"' data-rel='rel"+s.replace(' ','')+"' />"),seriesEl.firstChild );
					}
					if(type==='area'){
						seriesEl.insertBefore(pk.createEl("<path class='pk-area' fill='"+colors[s]+"' d='"+aPath.trim()+"' data-rel='rel"+s.replace(' ','')+"' />"),seriesEl.firstChild );
					}
					// console.log();
					groupEl.appendChild(seriesEl);
				};
				legend(seriesMeta); 			
			
			
			break;
		}
		/*
		END PIE CHART
		*/

		

		
		if(typeof legend === 'function'){			
			el.appendChild(legendEl);
		}
		el.appendChild(svgEl);
		
		return {
			0:el		
		}

		
    };
    return pk;
})(pk);

var pk = pk || {};

/**
Create a new checkbox control

HTML:

	<input type='checkbox' id='checkbox' />

Javascript:
	
	pk.checkbox({
		element: document.getElementById('checkbox'),
		label: 'Checked',
		value: true
	});
	
@class pk.checkbox
@constructor
@param options {Object}
@param options.element {Object} DOM element to convert to control
@param [options.value=0] {String} Value of initially selected option, defaults to the attribute value set on the passed element, or `0`
@param [options.name=pk-checkbox-RandInt] {String} Name of underlying input control, defaults to the attribute value set on the passed element, or `pk-checkbox-RandInt`
@param [options.label=label] {String} String to use for the control label, defaults to the attribute value set on the passed element, or its `innerHTML`
@param [options.tabindex=0] {Number} Tabindex of control, defaults to the attribute value set on the passed element, or `0`
@param [options.disabled=false] {Boolean} Disabled state of control, defaults to the attribute value set on the passed element, or `false`
@param [options.listeners] {Object} Object array of event listeners to bind to underlying input(s)
@return Object {Object} Consisting of original DOM element (item `0`) and class methods (see below)
@chainable
*/
(function(pk) {
    pk.checkbox = function(opt) {
        var el = opt.element,
            //    listeners = opt.listeners === undefined ? {} : opt.listeners,
            inputValue = opt.value || el.getAttribute('value') || 0,
            inputLabel = opt.label || el.getAttribute('label') || el.innerHTML,
            inputDisabled = (opt.disabled || el.getAttribute('disabled')) ? 'disabled' : '',
            inputName = opt.name || el.getAttribute('name') || 'pk-checkbox-' + pk.getRand(1, 999),
            listeners = opt.listeners === undefined ? {} : opt.listeners,
            inputTabIndex = opt.tabindex || el.getAttribute('tabindex') || 0;

        /*jshint multistr:true */
        var str = "<label class='pk-checkbox' for='" + inputName + "'>\
		<input type = 'checkbox'  id = '" + inputName + "'  name = '" + inputName + "'  value = '" + inputValue + "'  tabindex = '" + inputTabIndex + "' / >\
            <span class = 'pk-label' > " + inputLabel + " </span>\
		</label>";
        el.innerHTML = '';
        el = pk.replaceEl(el, str);
        /**
        Gets or sets control value
        @method val
        @param [value] {String} Value to set
        @return {String} Returns current value
        */

        /**
        Gets or sets control disabled state
        @method disabled
        @param [boolean] {Boolean} Disabled state
        @return {Boolean} Returns disabled state
        */
        var obj = {
            0: el,
            val: function(val) {
                if (val === undefined) {
                    return inputValue;
                }
                pk.attribute(el.children[0], 'checked', Boolean(val));
            },
            disabled: function(val) {
                if (val !== undefined) {
                    pk.toggleClass(el, 'pk-disabled', Boolean(val));
                    pk.attribute(el.children[0], 'disabled', Boolean(val));
                }
                return pk.attribute(el.children[0], 'disabled');
            }
        };
        obj.val(inputValue);
        if (inputDisabled) {
            obj.disabled(true);
        }
        pk.bindListeners(listeners, el.children[0]);
        return obj;
    };
    return pk;
})(pk);

var pk = pk || {};
/**
Create a new colorpicker control

HTML

	<div id='colorpicker'></div>

Javascript:

	pk.colorpicker({
		element: document.getElementById('colorpicker'),
		value:'#FF0000',
		listeners:{
			change:function(oldCol,newCol){
				// do something
			}
		}
	});
	
@class pk.colorpicker
@constructor
@param options {Object}
@param options.element {Object} DOM element to convert to control 
@param [options.value=#000000] {String} HEX string of initially selected color, defaults black `#000000`
@param [options.listeners] {Object} Object array of event listeners to bind (nb. only detects `change` event)
@return Object {Object} Consisting of original DOM element (item `0`) and class methods (see below)
@chainable
*/
(function(pk) {
    pk.colorpicker = function(opt) {


        var type = (window.SVGAngle || document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML"),
            listeners = opt.listeners === undefined ? {} : opt.listeners,
            el = opt.element,
            value = opt.value || '#000000',
            tpl = "<div class='pk-colorpicker'>\
				<div class='pk-colorpicker-area'>\
					<div class='pk-colorpicker-slPicker'></div>\
				</div>\
				<div class='pk-colorpicker-range'>\
					<div class='pk-colorpicker-hPicker'></div>\
				</div>\
			</div>";

        el = pk.replaceEl(el, tpl);
        var areaTpl, areaEl, rangeTpl, rangeEl;
        if (type === 'SVG') {
            areaTpl = "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' width='100%' height='100%'>\
				<defs>\
					<linearGradient id='gradient-black-0' x1='0%' y1='100%' x2='0%' y2='0%'>\
						<stop offset='0%' stop-color='#000000' stop-opacity='1'></stop>\
						<stop offset='100%' stop-color='#CC9A81' stop-opacity='0'></stop>\
					</linearGradient>\
					<linearGradient id='gradient-white-0' x1='0%' y1='100%' x2='100%' y2='100%'>\
						<stop offset='0%' stop-color='#FFFFFF' stop-opacity='1'></stop>\
						<stop offset='100%' stop-color='#CC9A81' stop-opacity='0'></stop>\
					</linearGradient>\
				</defs>\
				<rect x='0' y='0' width='100%' height='100%' fill='url(#gradient-white-0)'></rect>\
				<rect x='0' y='0' width='100%' height='100%' fill='url(#gradient-black-0)'></rect>\
			</svg>";
            rangeTpl = "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' width='100%' height='100%'>\
				<defs>\
					<linearGradient id='gradient-hsv-0' x1='0%' y1='100%' x2='0%' y2='0%'>\
						<stop offset='0%' stop-color='#FF0000' stop-opacity='1'></stop>\
						<stop offset='13%' stop-color='#FF00FF' stop-opacity='1'></stop>\
						<stop offset='25%' stop-color='#8000FF' stop-opacity='1'></stop>\
						<stop offset='38%' stop-color='#0040FF' stop-opacity='1'></stop>\
						<stop offset='50%' stop-color='#00FFFF' stop-opacity='1'></stop>\
						<stop offset='63%' stop-color='#00FF40' stop-opacity='1'></stop>\
						<stop offset='75%' stop-color='#0BED00' stop-opacity='1'></stop>\
						<stop offset='88%' stop-color='#FFFF00' stop-opacity='1'></stop>\
						<stop offset='100%' stop-color='#FF0000' stop-opacity='1'></stop>\
					</linearGradient>\
				</defs>\
				<rect x='0' y='0' width='100%' height='100%' fill='url(#gradient-hsv-0)'></rect>\
			</svg>";
        } else if (type === 'VML') {

            areaTpl = "<DIV style='position: relative; width: 100%; height: 100%'>\
				<v:rect style='position: absolute; top: 0; left: 0; width: 100%; height: 100%' stroked='f' filled='t'>\
				<v:fill type='gradient' method='none' angle='0' color='red' color2='red' colors='8519f fuchsia;.25 #8000ff;24903f #0040ff;.5 aqua;41287f #00ff40;.75 #0bed00;57671f yellow'></v:fill>\
				</v:rect>\
			</DIV>";

            rangeTpl = "<DIV style='position: relative; width: 100%; height: 100%'>\
				<v:rect style='position: absolute; left: -1px; top: -1px; width: 101%; height: 101%' stroked='f' filled='t'>\
					<v:fill type='gradient' method='none' angle='270' color='#FFFFFF' opacity='100%' color2='#CC9A81' o:opacity2='0%'></v:fill>\
				</v:rect>\
				<v:rect style='position: absolute; left: 0px; top: 0px; width: 100%; height: 101%' stroked='f' filled='t'>\
					<v:fill type='gradient' method='none' angle='0' color='#000000' opacity='100%' color2='#CC9A81' o:opacity2='0%'></v:fill>\
				</v:rect>\
			</DIV>";

            if (!document.namespaces['v']) {
                document.namespaces.add('v', 'urn:schemas-microsoft-com:vml', '#default#VML');
            }
        }



        areaEl = pk.createEl(areaTpl);
        rangeEl = pk.createEl(rangeTpl);
        el.children[0].appendChild(areaEl);
        el.children[1].appendChild(rangeEl);

        var lightnessEl = el.children[0].children[0];
        var hueEl = el.children[1].children[0];

        var hsv = {
            h: 0,
            s: 0,
            v: 0
        };
        var color = '#ffffff';

        function resolvePos(rEl, c) {
            var x = c.x,
                y = c.y,
                pEl = rEl.parentNode,
                pH = pk.layout(pEl).height,
                pW = pk.layout(pEl).width,
                h = pk.layout(rEl).height,
                w = pk.layout(rEl).width,
                prevCol = color;

            if (x) {
                if (c.x < 0) {
                    c.x = 0;
                } else if (c.x > 1) {
                    c.x = 1;
                }
                x = x * pW;
                if (x < 0 - w / 2) {
                    x = -1 * w / 2;
                } else if (x > pW - w / 2) {
                    x = pW - w / 2;
                }
                rEl.style.left = x + 'px';
            }
            if (y) {
                if (c.y < 0) {
                    c.y = 0;
                } else if (c.y > 1) {
                    c.y = 1;
                }
                y = y * pH;
                if (y < 0 - h / 2) {
                    y = -1 * h / 2;
                } else if (y > pH - h / 2) {
                    y = pH - h / 2;
                }
                rEl.style.top = y + 'px';
            }

            if (rEl === lightnessEl) {
                hsv.s = Math.round(c.x * 100);
                hsv.v = Math.round((1 - c.y) * 100);
                color = pk.color.hsv2hex([hsv.h, hsv.s, hsv.v]);
            }
            if (rEl === hueEl) {
                hsv.h = Math.round(c.y * 360);
                color = pk.color.hsv2hex([hsv.h, hsv.s, hsv.v]);
                lightnessEl.parentNode.style.backgroundColor = pk.color.hsv2hex([hsv.h, 100, 100]);
            }
            if (listeners.change && typeof listeners.change === 'function') {
                listeners.change(prevCol, color);
            }
        }
        pk.bindEvent('click', lightnessEl.parentNode, function(e) {
            if (e.target === lightnessEl) {
                return;
            }
            resolvePos(lightnessEl, {
                x: (pk.getEventOffset(e).x - pk.layout(lightnessEl).width / 2) / pk.layout(lightnessEl.parentNode).width,
                y: (pk.getEventOffset(e).y - pk.layout(lightnessEl).height / 2) / pk.layout(lightnessEl.parentNode).width
            });
        });
        pk.bindEvent('click', hueEl.parentNode, function(e) {
            if (e.target === hueEl) {
                return;
            }
            resolvePos(hueEl, {
                x: false,
                y: pk.getEventOffset(e).y / pk.layout(hueEl.parentNode).height
            });
        });
        pk.drag({
            element: hueEl.parentNode,
            move: false,
            container: {
                element: hueEl.parentNode
            },
            listeners: {
                dragging: function(el, e) {
                    resolvePos(hueEl, {
                        x: false,
                        y: e.dragPerc.y
                    });
                }
            }
        });

        pk.drag({
            element: lightnessEl.parentNode,
            move: false,
            container: {
                element: lightnessEl.parentNode
            },
            listeners: {
                dragging: function(el, e) {
                    resolvePos(lightnessEl, e.dragPerc);
                }
            }
        });
        /**
        Fired on selected color changing (click, drag)
        @event change
        @param oldColor {String} HEX color string of previous color
        @param newColor {String} HEX color string of new color
        */

        /**
        Gets or sets control value (HEX color string, e.g. `#000000`)
        @method val
        @param [value] {String} Value to set
        @return {String} Returns current value
        */

        var obj = {
            0: el,
            val: function(val) {
                if (!val) {
                    return color;
                }
                var hsvArr = pk.color.hex2hsv(val);
                hsv = {
                    h: hsvArr[0],
                    s: hsvArr[1],
                    v: hsvArr[2]
                };
                resolvePos(hueEl, {
                    x: false,
                    y: hsv.h / 360
                });
                resolvePos(lightnessEl, {
                    x: hsv.s / 100,
                    y: 1 - (hsv.v / 100)
                });
            }
        };
        obj.val(value);
        return obj;

    };
    return pk;
})(pk);

// Javascript Polyfill

// Production steps of ECMA-262, Edition 5, 15.4.4.14
// Reference: http://es5.github.io/#x15.4.4.14
// indexOf method

if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function(searchElement, fromIndex) {

        var k;

        if (this === null) {
            throw new TypeError('"this" is null or not defined');
        }

        var O = Object(this);
        var len = O.length || 0;

        if (len === 0) {
            return -1;
        }
        var n = +fromIndex || 0;

        if (Math.abs(n) === Infinity) {
            n = 0;
        }
        if (n >= len) {
            return -1;
        }
        k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
        while (k < len) {
            if (k in O && O[k] === searchElement) {
                return k;
            }
            k++;
        }
        return -1;
    };
}

// Pocketknife Core
/**
@module pocketknife
*/
var pk = pk || {};
(function(pk) {
/**
@class pk
@static
*/

/**
For the passed event object prevent bubbling up the DOM tree
@method preventBubble
@param event {Object} Event Object
@return {Boolean} Returns `false`
*/

    pk.preventBubble = function(e) {
        if (e.preventDefault) {
            e.preventDefault();
        }
        if (e.stopPropagation) {
            e.stopPropagation();
        }
        e.cancelBubble = true;
        e.returnValue = false;
        return false;
    };

/**
For the passed element, toggle presence of CSS class
@method toggleClass
@param element {Object} DOM element
@param class {String} CSS class
@param toggle {Boolean} Optional. `true` to add class if not present, `false` to remove. If ommitted, method will detect and apply/remove as necessary.
@return {Boolean} `true` if class added, `false` if removed.
*/


    pk.toggleClass = function(el, c, t) {
        if (t === true) {
            pk.addClass(el, c);
            return true;
        } else if (t === false) {
            pk.removeClass(el, c);
            return false;
        }
        pk.toggleClass(el, c, !pk.hasClass(el, c));
        return pk.hasClass(el, c);
    };

/**
For the passed element, detect presence of CSS class
@method hasClass
@param element {Object} DOM element
@param class {String} CSS class
@return {Boolean} `true` if class found, `false` if not.
*/

    pk.hasClass = function(el, c) {
        var ca = el.getAttribute('class') || '';
        return (ca && ca.indexOf(c) > -1) ? true : false;
    };
/**
For the passed element, center horizontally and vertically within the parentNode
@method center
@param element {Object} DOM element
@return {Object} Returns passed DOM element
@chainable
*/    
    pk.center = function(el) {
        el.style.top = el.parentNode.clientHeight / 2 - (el.offsetHeight / 2) + 'px';
        el.style.left = el.parentNode.clientWidth / 2 - (el.offsetWidth / 2) + 'px';
   return el;
/**
For the passed element, get the passed style property value
@method getStyle
@param element {Object} DOM element
@param property {String} Style property to fetch
@return {String} Returns style property value
*/   
    };
    pk.getStyle = function(el, p) {
        return window.getComputedStyle(el).getPropertyValue(p);
    };


/**
For the passed element, add CSS class
@method addClass
@param element {Object} DOM element
@param class {String} CSS class
@return {Object} Returns passed DOM element
@chainable
*/  
    pk.addClass = function(el, c) {
        if (pk.hasClass(el, c)) {
            return;
        }
        var ca = el.getAttribute('class') || '';
        el.setAttribute('class', (ca ? ca + ' ' : '') + c);
        return el;
    };
/**
For the passed element, remove CSS class
@method removeClass
@param element {Object} DOM element
@param class {String} CSS class
@return {Object} Returns passed DOM element
@chainable
*/  
    pk.removeClass = function(el, c) {
        var ca = el.getAttribute('class');
        if (!ca) {
            return;
        }
        if(ca===c){
            el.removeAttribute('class');
        }else{
            el.setAttribute('class', ca.replace(c, '').trim());
        }
        return el;
    };
/**
Bind an element handler to a DOM node
@method bindEvent
@param event {String} Event type to bind
@param element {Object} DOM element
@param function {Function} Event handler to bind, function is passed originating event when called 
@return {Object} Returns passed DOM element
@chainable
*/      
    pk.bindEvent = function(e, el, fn) {
        if (e === "mousewheel") {
            e = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel"; //FF doesn't recognize mousewheel as of FF3.x  
        }
        if (el.addEventListener) {
            el.addEventListener(e, fn, false);
        } else {
            el.attachEvent("on" + e, fn);
        }
        return el;
    };
/**
Unbind an element handler from a DOM node
@method unbindEvent
@param event {String} Event type to bind
@param element {Object} DOM element
@param function {Function} Event handler to unbind 
@return {Object} Returns passed DOM element
@chainable
*/      
	pk.unbindEvent = function(e, el, fn) {
		if (el.removeEventListener){
			el.removeEventListener (e,fn,false);
		}
		if (el.detachEvent){
			el.detachEvent ('on'+e,fn); 
		}
        return el;
	};

/**
Calculate positioning properties of passed DOM element, optionally augment passed event using `procEvent` for event based positioning
@method layout
@param element {Object} DOM element
@param [event] {Object} Event
@return {Object} Returns object consisting of `top`, `right`, `bottom`, `left`, `height` and `width` values as well as sub `offset` and `parent` objects
*/  
	pk.layout=function(el, e){
		if(e){e=pk.procEvent(e);}
		var p={
			offset:el.getBoundingClientRect(),
			parent:{ 
				top:el.offsetTop,
				left:el.offsetLeft
			},
			height:el.offsetHeight,
			width:el.offsetWidth
		};
	 
		p.top=p.offset.top+(document.documentElement && document.documentElement.scrollTop!==0 ? document.documentElement.scrollTop :  document.body.scrollTop);
		p.left=p.offset.left+(document.documentElement && document.documentElement.scrollLeft!==0 ? document.documentElement.scrollLeft :  document.body.scrollLeft);
		return p;
	};
/**
Apply a series of event listeners to a DOM element
@method bindListeners
@param listeners {Object} Consisting of event objects to pass to `bindEvent` method
@param element {Object} DOM element
@return {Object} Returns passed DOM element
@chainable
*/ 
    pk.bindListeners = function(l, el) {
        for (var e in l) {
			if(l.hasOwnProperty(e)){
				pk.bindEvent(e, el, l[e]);
			}
        }
        return el;
    };
/**
Generate a random number between the passed `min` and `max` values
@method getRand
@param min {Number} Minimum value of calculated number
@param max {Number} Maximum value of calculated number
@return {Number} Returns pseudo-random number between §min§ and §max§
*/     
    pk.getRand = function(min, max) {
        return Math.floor(Math.random() * (max - min)) + min;
    };
/**
Extract unit type from passed string
@method getUnits
@param String {String} Alphanumeric string (e.g. style property value)
@return {String} Returns unit type
*/         
    pk.getUnits = function(str) {
        return str.replace(/\d+/, '');
    };
	
/**
Finds matching DOM elements within passed DOM element
@method findEl
@param element {Object} DOM element to search within
@param opt {Object} Object of find parameters
@param [opt.type] {String} Element type to filter
@param [opt.class] {String} Class type to filter
@param [opt.attribute] {Object} Attribute to filter
@param [opt.attribute.name] {String} Attribute name to filter
@param [opt.attribute.value] {String} Attribute value to filter
@return {Array} Returns matching DOM elements
*/     
    pk.findEl = function(el, opt) {		
	
	 var nodes=[],
		 nType=opt.type || null,
		 nAttr=opt.attribute || null,
		 nClass=opt.class || null;
		var nodes=[],
			treeWalker = document.createTreeWalker(el, NodeFilter.SHOW_ELEMENT, null, false);
		do {			
			if(treeWalker.currentNode.tagName!==undefined){
				var match=true; 				
				if(nType && treeWalker.currentNode.tagName.toLowerCase()!==nType.toLowerCase()){
					match=false;
				}
				if(nClass && !pk.hasClass(treeWalker.currentNode, nClass)){
					match=false;
				}
				if(
					(nAttr && !treeWalker.currentNode.hasAttribute(nAttr.name)) 
					||
					(nAttr && treeWalker.currentNode.hasAttribute(nAttr.name) && treeWalker.currentNode.getAttribute(nAttr.name) !== nAttr.value)){
					match=false;
				}
				if(match){
					nodes.push(treeWalker.currentNode);
				}
			}
			
		} while (treeWalker.nextNode());
		return nodes;	
    };	
	
/**
Wrap the passed DOM element in a new DOM node created from the `wrapper` string
@method wrapEl
@param element {Object} DOM element to wrap
@param wrapper {String} HTML string representing the new DOM wrapper
@return {Object} Returns newly created DOM wrapper element
@chainable
*/     
    pk.wrapEl = function(el, str) {
        var helperEl = pk.createEl(str);
        el.parentNode.insertBefore(helperEl, el);
        helperEl.appendChild(el);
        return helperEl;
    };
/**
Create a new DOM element from the passed `HTML` string (SVG agnostic)
@method createEl
@param HTML {String} HTML string representing the new DOM element
@return {Object} Returns newly created DOM element
@chainable
*/  
	
	pk.createEl = function(str, attr) {
		var el = document.createElement('div');    
		if (['<g', '<path', '<line', '<circle', '<rect'].some(function(v) { return str.indexOf(v) >= 0; })) {    
			el.innerHTML = '<svg>' + str + '</svg>';
			return el.firstChild.firstChild;    
		}else{
			el.innerHTML = str;
			return el.firstChild;  
		}
	};

	
/**
Get the index of the passed DOM node within the immediate parent
@method getIndex
@param element {Object} DOM element to return index for
@return {Number} Returns index of passed element
*/  
    pk.getIndex = function(el) {
        if (!el) {
            return null;
        }
        var prop = document.body.previousElementSibling ? 'previousElementSibling' : 'previousSibling';
        var i = 1;
        while ((el = el[prop])) {
            ++i;
        }
        return i - 1;
    };
                            /**
Replace the passed DOM element with a new element created from the passed string, inclusive of all original attributes
@method replaceEl
@param element {Object} The DOM eleemnt to replace
@param HTML {String} HTML string representing the new DOM element
@return {Object} Returns newly created DOM element
@chainable
*/  
    pk.replaceEl = function(el, str) {
        var newEl = pk.createEl(str);
        for (var i = 0; i < el.attributes.length; i++) {
            newEl.setAttribute(el.attributes[i].nodeName, el.attributes[i].value);
        }
        while (el.firstChild) {
            newEl.appendChild(el.firstChild);
        }
        el.parentNode.replaceChild(newEl, el);
        return newEl;
    };
/**
Forces the passed variable into an array, xploding comma seperated strings, keeping existing arrys, collapsing objects and or converting strings as necessary
@method toArr
@param variable {Undefined} Variable to force into array
@return {Array} Returns array of passed variable
*/  
    pk.toArr = function(v) {	
        var a = [];
        if (v && typeof v !== "object") {
            if (v.indexOf(',') !== -1) {
                a = v.split(',');
            } else {
                a.push(v);
            }
        } else {
            a = v;
        }
        return a;
    };
/**
Collides two arrays, either replacing one with the other, removing one from another, adding one to another or toggling the values of one in another
@method collide
@param array1 {Array} Base array
@param array2 {Array} Collider array
@param [type=0] {Number} Type of collision, `0` default, replace `array1` with `array2`, `1` add `array2` to `array1`, `2` remove `array2` from `array1`, `3` toggle `array2` values in `array1` (intelligent add/replace)
@return {Array} Returns resulting `array`
*/  
    pk.collide = function(a1, a2, s) {
        s = s || 0;
        a1 = pk.toArr(a1);
        a2 = pk.toArr(a2);
        /* 
            s = switch
            0 (default) = replace a1 with a2
            1 = add a2 to a1
            2 = remove a2 from a1
            3 = toggle a2 in a1 and add/remove items if not/found                
        */
        if (s === 0) {
            return a2;
        }
        for (var i=0;i< a2.length;i++) {
            var f = a1.indexOf(a2[i]) !== -1 ? true : false;
            if (!f && (s === 1 || s === 3)) {
                a1.push(a2[i]);
            } else if (f && (s === 2 || s === 3)) {
                a1.splice(parseInt(a1.indexOf(a2[i]), 0), 1);
            }
        }
        return a1;
    };
/**
Returns normalized percentage value
@method perc
@param Value {Float} value (amount)
@param Total {Float} total (out of)
@return {Float} Returns noramlized percentage value between 1 and 0
*/ 	
    pk.perc = function(v,t) {
        v=v/t;
		v = v < 0 ? 0 : v;
		v = v > 1 ? 1 : v;		
        return v;
    };	
/**
Gets of sets attribute values, either explicitly or implicitly declared
@method attribute
@param element {Object} Related DOM element
@param attribute {String} Attribute name to get/set for single attribute, or `Array` of attribute:value Objects to set multiple attributes
@param [value] {String} Optional to get, or value of type specific to attribute if single attribute being set
@return {Object} Returns `element`
@chainable
*/ 
    pk.attribute = function(el, attr, val) {
        if (typeof el !== "object") {
            return false;
        }
		// get value
        if(typeof attr == "string" && val===undefined){
			attr = el.hasAttribute(attr) ? attr : el.hasAttribute('data-' + attr) ? 'data-' + attr : attr;	
			if (attr === 'selected' || attr === 'disabled' || attr === 'checked') {		
				el.removeAttribute(attr);
				return el[attr];
			}else{
				return el.getAttribute(attr);
			}		
		}else{
			// set value	
			if(typeof attr !== "object"){
				var tmp=attr;
				attr={}
				attr[tmp]=val;
			}
			for(var a in attr){
				a = el.hasAttribute(a) ? a : el.hasAttribute('data-' + a) ? 'data-' + a : a;	
				if(a === 'selected' || a === 'disabled' || a === 'checked'){
					el.removeAttribute(a);
					el[a]=attr[a];
				}else{
					el.setAttribute(a, attr[a]);
				}					
			}		
			return el;	
		}		
    };
/**
Augments event object with additional X and Y helper coordinates
@method procEvent
@param event {Object} Event to normalize
@return {Object} Returns object with the additional attributes `posX`, `posY` are normalized absolutes, `offsetX`, offsetY` are normalized parent offsets, `viewportX`, `viewportY` are normalized viewport offsets
*/     
    pk.procEvent=function(e){
        e.posX = 0;
        e.posY = 0;
        if (!e) var e = window.event;
        if (e.pageX || e.pageY)     {
            e.posX = e.pageX;
            e.posY = e.pageY;
        }
        else if (e.clientX || e.clientY)    {
            e.posX = e.clientX + document.body.scrollLeft
                + document.documentElement.scrollLeft;
            e.posY = e.clientY + document.body.scrollTop
                + document.documentElement.scrollTop;
        }
        if(e.offsetX===undefined){
            e.offsetX=e.layerX;
        }
        if(e.offsetY===undefined){
            e.offsetY=e.layerY;
        }
        e.viewportY=e.posY-document.body.scrollTop;
        e.viewportX=e.posX-document.body.scrollLeft;
        return e;
    }
/**
Gets browser agnostic offset coordinates for applicable mouse events
@method getEventOffset
@param event {Object} Event to normalize
@return {Object} Returns object comprising of normalized `x` and `y` offsets
*/ 
	pk.getEventOffset=function(e){
		return {
			x:e.offsetX===undefined?e.layerX:e.offsetX,
			y:e.offsetY===undefined?e.layerY:e.offsetY
		};
	};
	
    window.onload=function(){pk.addClass(document.body, 'pk-ui');}
})(pk);

var pk = pk || {};
/**
Create a new datepicker control

HTML

    <div id='datepicker'></div>

Javascript

	pk.datepicker({
		element: document.getElementById('datepicker')
	});	
			
	
@class pk.datepicker
@constructor
@param options {Object}
@param options.element {Object} DOM element to convert to control
@param [options.value=0] {String} Value of initially selected option, defaults to the attribute value set on the passed element, or `0`
@param [options.name=pk-select-RandInt] {String} Name of underlying input control, defaults to the attribute value set on the passed element, or `pk-select-RandInt`
@param [options.tabindex=0] {Number} Tabindex of control, defaults to the attribute value set on the passed element, or `0`
@param [options.disabled=false] {Boolean} Disabled state of control, defaults to the attribute value set on the passed element, or `false`
@return Object {Object} Consisting of original DOM element (item `0`) and class methods (see below)
@chainable
*/
(function(pk) {
    pk.datepicker = function(opt) {
		var y = opt.year || 2014,
			m = opt.month || 11,
			d = opt.day || 1,
			weekday={
				s:['M','T','W','T','F','S','S'],
				m:['Mon','Tue','Wed','Thu','Fri','Sat','Sun'], 
				l:['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday']		
			},
			month={
				m:['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec']		
			},
			tpl="<div class='pk-datepicker'></div>",			
			el=opt.element,
			yearEl=null,
			yearsEl=null,
			monthEl=null,
			daysEl=null,
			sD=0,
			eD=0,
			pD=0;
		el=pk.replaceEl(el, tpl);		
		function parseDate(){
			function normalizeDay(v){
				if(v===0){
					return 6;
				}else{
					return v-1;
				}				
			}
			var obj= {		
				weekday:normalizeDay(new Date(y, m-1, d).getDay()),
				startday:normalizeDay(new Date(y, m-1, 1).getDay()),
				endday:new Date(y, m, 0).getDate(),
				prevend:new Date(y, m-1, 0).getDate(),
				nextend:new Date(y, (m===11 ? 0 : m+1), 0).getDate(),
				date:new Date(y, m-1, d)
			}
			return obj; 
		}
		
		function createDays(){
			sD=parseDate().startday,
			eD=parseDate().endday, 
			pD=parseDate().prevend; 	
				
			sD = sD == 0 ? sD = 7 : sD;
			tpl="<thead><tr>";
			for(var w=0;w<7;w++){		
				tpl+="<th>"+weekday.m[w]+"</th>";
			}
			tpl+="</tr></thead><tbody>";		
			for(var c=0;c<42;c++){		
				if(c%7 === 0){
					tpl+="<tr>";
				}
				if(c>=sD && c<=eD+sD-1){
					tpl+="<td data-day='"+(c-sD+1)+"'>"+(c-sD+1)+"</td>";
				}else if(c<sD){
					tpl+="<td class='pk-prev' data-day='"+(pD-(sD-c-1))+"' data-month='"+(m-2 < 0 ? 11 : m-2)+"' "+(m-2 < 0 ? "data-year='"+(y-1)+"'": '')+">"+(pD-(sD-c-1))+"</td>"; 
				}else{
					tpl+="<td class='pk-next' data-day='"+(c-sD-eD+1)+"' data-month='"+(m===12 ? 0 : m)+"' "+(m===12 ? "data-year='"+(y+1)+"'": '')+">"+(c-sD-eD+1)+"</td>"; 
				}
				if(c%7 === 6){
					tpl+="</tr>";
				}
			}
			tpl+="</tbody>"; 	
			daysEl.innerHTML=tpl;
			setDay();			
		}
		
		
		function createYears(){
		
			for(i=0;i<55;i++){
				if(i%5 === 0){
					tpl+="<tr>";					
				}
				tpl+="<td>"+(y+i)+"</td>";	 
				if(i%5 === 4){
					tpl+="</tr>";				
				}
			}		
			yearsEl.innerHTML=tpl;
		}
		
		metaEl=pk.createEl("<div class='pk-datepicker-meta'>"+666+"</div>");
		el.appendChild(metaEl);			
		yearEl=pk.createEl("<div class='pk-datepicker-year'>"+y+"</div>");
		el.appendChild(yearEl);
		
		tpl="<ul class='pk-datepicker-month'>";
		for(var n=0;n<12;n++){		
			tpl+="<li data-month='"+n+"'>"+month.m[n]+"</li>";
		}
		tpl+="</ul>";
		monthEl=pk.createEl(tpl);
		el.appendChild(monthEl);	
		
		
		tpl="<table class='pk-datepicker-day'></table>";
		daysEl=pk.createEl(tpl);
		el.appendChild(daysEl);		
		
			
		yearsEl=pk.createEl("<table class='pk-datepicker-years'></table>");
		el.appendChild(yearsEl); 
		createYears();
		
		setMeta();
		setYear();
		
		function setMeta(){
			function getSuffix(n) {return n + (n < 11 || n > 13 ? ['st', 'nd', 'rd', 'th'][Math.min((n - 1) % 10, 3)] : 'th');}
			var mDate=parseDate();
			metaEl.innerHTML=weekday.l[mDate.weekday]+" "+getSuffix(mDate.date.getDate())+" "+month.m[mDate.date.getMonth()]+" "+mDate.date.getFullYear();
		}
		function setYear(){		
			yearEl.innerHTML=y;
			setMonth();
		}		
		function setMonth(){		
			for(var n=0;n<12;n++){			
				pk.removeClass(monthEl.children[n], 'selected');
			}
			pk.addClass(monthEl.children[m-1], 'selected');
			createDays();	
		}
		function setDay(){	
			var i=0;
			for(w=0;w<6;w++){
				for(c=0;c<7;c++){
					i++;	 				
					pk.removeClass(daysEl.children[1].children[w].children[c], 'selected');
					if(i===sD+d){
						pk.addClass(daysEl.children[1].children[w].children[c], 'selected');
					}
				}		
			}
		}				
		function resolveClick(e){
			var tEl=e.target;
			if(pk.attribute(tEl, 'year')!==null){ 			
				y=parseInt(pk.attribute(tEl, 'year'),0);	
				setYear();		
			}			
			if(pk.attribute(tEl, 'month')!==null){
				m=parseInt(pk.attribute(tEl, 'month'),0)+1;		
				setMonth();				
			}
			if(pk.attribute(tEl, 'day')!==null){ 			
				d=parseInt(pk.attribute(tEl, 'day'),0);		
				setDay();
			}
			setMeta();
		}
		pk.bindEvent('click', el, resolveClick);	

		pk.bindEvent("mousewheel", yearEl, function(e) { 
			pk.preventBubble(e);
			if (e.wheelDelta > 0 || e.detail < 0) {
				y++
            }else{ 
				y--; 
			}
			setYear();
			setMeta();
		});		
		pk.bindEvent("mousewheel", monthEl, function(e) { 
			pk.preventBubble(e);
			if (e.wheelDelta > 0 || e.detail < 0) {
				d=d > parseDate().nextend ? parseDate().nextend : d;
				if(m===12){
					m=1;
					y++;
				}else{
					m++;
				}
            }else{
				d=d > parseDate().prevend ? parseDate().prevend : d;
				if(m===1){
					m=12;
					y--;
				}else{
					m--;
				}
			}
			setYear();
			setMeta();
		});
		pk.bindEvent("mousewheel", daysEl, function(e) { 
		 	pk.preventBubble(e); 
			if (e.wheelDelta > 0 || e.detail < 0) {
				if(d===eD){				
					d=1;
					if(m===12){
						m=1;
						y++;
						setYear();
					}else{
						m++;
						setMonth();
					}
				}else{
					d++;
					setDay();
				}
            }else{
				if(d===1){				
					d=parseDate().prevend;
					if(m===1){
						m=12;
						y--;
						setYear();
					}else{
						m--;
						setMonth();
					}
				}else{
					d--;
					setDay();
				}
			}
			setMeta();
        });
		return {
			0:el		
		}
		
    };
    return pk;
})(pk);

var pk = pk || {};
/**
Utility class for creating draggable elements

HTML:

	<div id='draggable'></div>

Javascript:
	
	pk.drag({
		element: document.getElementById('draggable'),
		move: true,
		container:{
			element:document.body,
			style:'restrict'
		},
		listeners: {
			dragstart: function() {
				// started dragging
			},
			dragging: function() {
				// dragging
			},
			dragend: function() {
				// stopped dragging
			}
		}
	});

@class pk.drag
@constructor
@param options {Object}
@param options.element {Object} DOM element to attach drag handlers to
@param [options.handle=element] {Object} DOM element (child of `element`) to use as drag handle
@param options.move {Object} Show movement during drag, either `true`, `false` or an object consisting of `x` and `y` {Boolean} values
@param options.container {Object} Object containing details about container
@param options.container.element=document.body {Object} DOM element used as container, defaults to `document.body`
@param options.container.style=restrict {String} Type of containment, either `restrict`, `snap` or {Object} consisting of `x` and `y` values calculated relative to `container.element`
@param [options.listeners] {Object} Object array of event listeners to bind to underlying element(s) - consisting of `dragstart`, `dragend` and `dragging`
@return Object {Object} Consisting of original DOM element (item `0`)
@chainable
*/
(function(pk) {
    pk.drag = function(opt) {
        var el = opt.element;
        var handle = opt.handle || opt.element;
        var container = {
            element: opt.container && opt.container.element ? opt.container.element : document.body,
            style: opt.container && opt.container.style ? opt.container.style : 'restrict'
        };

        pk.addClass(handle, 'pk-drag');
        var fn = opt.listeners;
        var m = opt.move;
        if (m && typeof m !== 'object') {
            m = {
                x: true,
                y: true
            };
        }
        var dragging = false;
        var dragStart = {};
        var startOffset;

        function augmentEvent(e) {

                e.dragStart = dragStart;
                e.dragOffset = startOffset;
 
                e.dragEnd = {
                    x: e.clientX,
                    y: e.clientY
                };
                e.dragDist = {
                    x: e.dragEnd.x - e.dragStart.x,
                    y: e.dragEnd.y - e.dragStart.y
                };
                e.dragPerc = {
                    x: ( e.dragDist.x + e.dragOffset.x) / pk.layout(container.element).width,
                    y: ( e.dragDist.y + e.dragOffset.y) / pk.layout(container.element).height
                };
                return e;
            }
            /**
            Fired on drag event starting
            @event dragstart
            @param element {Object} Element event fired on
            @param event {Object} Event object
            */

        /**
        Fired on during drag event
        @event dragging
        @param element {Object} Element event fired on
        @param event {Object} Event object
        */

        /**
        Fired on drag event ending
        @event dragend
        @param element {Object} Element event fired on
        @param event {Object} Event object
        */
        pk.bindEvent("mousedown", handle, function(e) {
            dragging = true;
            dragStart = {
                x: e.clientX,
                y: e.clientY
            };
            startOffset = {
                x: e.clientX - el.getBoundingClientRect().left,
                y: e.clientY - el.getBoundingClientRect().top
            };
            e = augmentEvent(e);
            pk.addClass(handle, 'pk-drag-dragging');
            pk.addClass(document.body, 'pk-noselect');
            document.onselectstart = function() {
                return false;
            };
            if (fn && fn.dragstart) {
                fn.dragstart(el, e);
            }
        });
        pk.bindEvent("mouseup", window, function(e) {
            if (!dragging) {
                return;
            }
            dragging = false;
            e = augmentEvent(e);
            pk.removeClass(handle, 'pk-drag-dragging');
            pk.removeClass(document.body, 'pk-noselect');
            document.onselectstart = function() {
                return true;
            };
            if (m && container.style === "snap") {
                contain();
            }
            if (fn && fn.dragend) {
                fn.dragend(el, e);
            }
        });

        function contain() {


            var h = container.element.tagName === "BODY" ? document.documentElement.clientHeight : container.element.offsetHeight,
                w = container.element.tagName === "BODY" ? document.documentElement.clientWidth : container.element.offsetWidth,
                oX = container.style.x || 0,
                oY = container.style.y || 0;

            if (m.x && el.offsetLeft < (0 + oX)) {
                el.style.left = (0 + oX) + 'px';
            } else if (m.x && el.offsetLeft > w - el.offsetWidth - oX) {
                el.style.left = w - el.offsetWidth - oX + 'px';
            }
            if (m.y && el.offsetTop < (0 + oY)) {
                el.style.top = (0 + oY) + 'px';
            } else if (m.y && el.offsetTop > h - el.offsetHeight - oY) {
                el.style.top = h - el.offsetHeight - oY + 'px';
            }
        }
        pk.bindEvent("mousemove", window, function(e) {
            if (!dragging) {
                return;
            }
            e = augmentEvent(e);
            if (m.x) {
                el.style.left = el.offsetLeft + (e.dragEnd.x - el.getBoundingClientRect().left) - e.dragOffset.x + 'px';
            }
            if (m.y) {
                el.style.top = el.offsetTop + (e.dragEnd.y - el.getBoundingClientRect().top) - e.dragOffset.y + 'px';
            }
            if (container.style === "restrict" || container.style.x || container.style.y) {
                contain();
            }
            if (fn && fn.dragging) {
                fn.dragging(el, e);
            }
        });
        return {
            0: el
        };
    };
})(pk);

var pk = pk || {};

/**
Create a new modal component

HTML:

	<button onclick="showModal();">Show Modal</button>

Javascript: 

	function showModal(){
		pk.modal({
			header:'Modal header',
			content:'Modal content', 
			draggable:true
		});
	}

@class pk.modal
@constructor
@param options {Object}
@param options.element {Object} DOM element to convert to component
@param [options.header] {String} Modal header content (`HTML` allowed)
@param [options.content] {String} Modal body content (`HTML` allowed)
@param [options.draggable] {Boolean} Whether to allow modal dragging
@return Object {Object} Consisting of original DOM element (item `0`) and class methods (see below)
@chainable
*/

(function(pk) {
    pk.modal = function(opt) {
        var h = opt.header,
            c = opt.content;
        /*jshint multistr: true */
        var tpl = "<div class='pk-modal-mask'>\
			<div class='pk-modal-box pk-animated'>\
				<div class='pk-modal-header'>" + h + "<span class='pk-modal-close'></span></div>\
				<div class='pk-modal-content'>" + c + "</div>\
			</div>\
		</div>";

        var el = pk.createEl(tpl),
            box = el.children[0],
            header = box.children[0],
            close = header.children[0];

        if (document.body.children.length > 0) {
            document.body.insertBefore(el, document.body.children[0]);
        } else {
            document.body.appendChild(el);
        }

        function closeModal() {
            pk.removeClass(el, 'pk-show');
            setTimeout(function() {
                el.parentNode.removeChild(el);
            }, 500);
        }
        pk.bindEvent("click", el, function(e) {
            if (e.target !== el) {
                return;
            }
            closeModal();
        });
        pk.bindEvent("click", close, closeModal);
        pk.bindEvent("resize", window, function() {
            pk.center(box);
        });
        setTimeout(function() {
            pk.addClass(el, 'pk-show');
        }, 10);

        var boxH = box.offsetHeight || 0;
        setInterval(function() {
            var boxHN = box.offsetHeight;
            if (boxH !== boxHN) {
                pk.center(box);
                boxH = boxHN;
            }
        }, 500);
        pk.center(box);

        if (opt.draggable !== false && pk.drag) {
            pk.drag({
                element: box,
                handle: header,
                move: true,
                listeners: {
                    dragstart: function() {
                        pk.removeClass(box, 'pk-animated');
                    },
                    dragend: function() {
                        pk.addClass(box, 'pk-animated');
                    }
                }
            });
        }
        /**
        Closes modal and removes from DOM
        @method close
        */
        return {
            0: el,
            close: closeModal
        };
    };
    return pk;
})(pk);

var pk = pk || {};
/**
Class used for notification management

HTML

    <button onclick="showNotification();">Show Notification</button>

Javascript:

	function showNotification(){
		pk.notify.push({
			content:'Default message'
		});
	}

@class pk.notify
@static
*/

/**
Create a new notification
@method add
@param options {Object}
@param [options.content] {String} Notification content (`HTML` allowed)
@param [options.delay=8000] {Number} Time in `ms` for notificaiton to display for
@return Object {Object} Returns notification element (item `0`)
*/

/**
Remove a notification
@method remove
@param element {Object} Notification element to remove
*/
(function(pk) {
    var nEl = pk.createEl("<ul class='pk-notify'></ul>");
    document.body.appendChild(nEl);
    pk.notify = {
        add: function(opt) {
            var mEl = pk.createEl("<li tabindex='" + pk.getRand(1, 999) + "'>" + opt.content + "</li>"),
                delay = opt.delay || 8000;
            nEl.appendChild(mEl);
            setTimeout(function() {
                pk.addClass(mEl, 'pk-show');
            }, 10);
            var scope = this;
            setTimeout(function() {
                scope.remove(mEl);
            }, delay);

            pk.bindEvent('click', mEl, function() {
                scope.remove(mEl);
            });
            return {
                0: mEl
            };
        },
        remove: function(dEl) {
            if (!pk.hasClass(dEl, 'pk-show')) {
                return;
            }
            pk.removeClass(dEl, 'pk-show');
            setTimeout(function() {
                if (dEl) {
                    nEl.removeChild(dEl);
                }
            }, 1000);
        }
    };
})(pk);

var pk = pk || {};
/**
Create a new rating control

HTML:

	<input id='rating' />
	
Javascript:

	pk.rating({
		element: document.getElementById('rating'),
		value: 3
	});

@class pk.rating 
@constructor
@param options {Object}
@param options.element {Object} DOM element to convert to control
@param options.count {Number} Number of items
@param [options.value=0] {String} Value of initially selected option, defaults to the attribute value set on the passed element, or `0`
@param [options.name=pk-toggle-RandInt] {String} Name of underlying input control, defaults to the attribute value set on the passed element, or `pk-toggle-RandInt`
@param [options.tabindex=0] {Number} Tabindex of control, defaults to the attribute value set on the passed element, or `0`
@param [options.disabled=false] {Boolean} Disabled state of control, defaults to the attribute value set on the passed element, or `false`
@param [options.listeners] {Object} Object array of event listeners to bind to underlying input(s)
@return Object {Object} Consisting of original DOM element (item `0`) and class methods (see below)
@chainable
*/
(function(pk) {
    pk.rating = function(opt) {
        var el = opt.element,
            listeners = opt.listeners === undefined ? {} : opt.listeners,
            inputValue = opt.value || el.getAttribute('value') || 0,
            inputDisabled = (opt.disabled || el.getAttribute('disabled')) ? 'disabled' : '',
            inputName = opt.name || el.getAttribute('name') || 'pk-rating-' + pk.getRand(1, 999),
            inputTabIndex = opt.tabindex || el.getAttribute('tabindex') || 0,
            lastVal = inputValue,
			count=opt.count || 5;


			
        /*jshint multistr:true */
        var str = "<div class='"+ (opt.stages ? 'pk-stages' : 'pk-rating') +"'><fieldset tabindex='"+inputTabIndex+"'>";
			for(var o = count; o > 0; o--){			 
				var style='';
				if(opt.stages){
					style="style='width:"+(100/count)+"%;z-index:"+(count-o)+"'";
				}
				str+="<input type='radio' id='" + inputName + "_"+o+"' name='" + inputName + "' value='"+o+"'/><label for='" + inputName + "_"+o+"' data-label='"+o+"' "+style+"></label>";			
			}				
            str+="</fieldset></div>";
        el = pk.replaceEl(el, str);

        var rEl = [];
        rEl.push(el.children[0].children[8]);
        rEl.push(el.children[0].children[6]);
        rEl.push(el.children[0].children[4]);
        rEl.push(el.children[0].children[2]);
        rEl.push(el.children[0].children[0]);
        pk.bindListeners(listeners, rEl[0]);
        pk.bindListeners(listeners, rEl[1]);
        pk.bindListeners(listeners, rEl[2]);
        pk.bindListeners(listeners, rEl[3]);
        pk.bindListeners(listeners, rEl[4]);

        pk.bindEvent("mousewheel", el, function(e) {
            pk.preventBubble(e);
            var offset = 1;
            if (e.wheelDelta < 0 || e.detail > 0) {
                offset = -1;
            }
            obj.val(obj.val() + offset);
        });

        function clickHandler() {
            if (lastVal === obj.val()) {
                obj.val(obj.val() - 1);
            }
            lastVal = obj.val();
        }
        for (var i = 0; i < rEl.length; i++) {
            pk.bindEvent('click', rEl[i], clickHandler);
        }
        /**
        Gets or sets control value
        @method val
        @param [value] {String} Value to set
        @return {String} Returns current value
        */

        /**
        Gets or sets control disabled state
        @method disabled
        @param [boolean] {Boolean} Disabled state
        @return {Boolean} Returns disabled state
        */
        var obj = {
            0: el,
            val: function(val) {
                if (val === undefined) {
                    for (var r in rEl) {
                        if (rEl[r].checked) {
                            val = rEl[r].value;
                            break;
                        }
                    }
                    return parseInt(val === undefined ? 0 : val, 0);
                }
                val = val < 0 ? 0 : val;
                val = val > 5 ? 5 : val;
                if (val === 0) {
                    rEl[0].checked = true;
                    rEl[0].checked = false;
                } else {
                    rEl[val - 1].checked = true;
                }
                lastVal = val;
            },
            disabled: function(val) {
                if (val !== undefined) {
                    pk.toggleClass(el, 'pk-disabled', val);
                    for (var r = 0; r < rEl.length; r++) {
                        pk.attribute(rEl[r], 'disabled', val);
                    }
                }
                return pk.attribute(rEl[0], 'disabled');
            }
        };
        obj.val(inputValue);
        if (inputDisabled) {
            obj.disabled(true);
        }
        return obj;
    }; 
    return pk;
	
})(pk);

var pk = pk || {};
/**
Attach custom scrollbars to an element

HTML:

	<div id='scroll'>
		...long content....
    </div>
	
Javascript:

	pk.scroll({
		element: document.getElementById('scroll'),
		axis: 'xy'
	});
	
@class pk.scroll
@constructor
@param options {Object}
@param options.element {Object} DOM element to attach drag handlers to
@param [options.axis=y] {Object} Object consisting of `x` and `y` {Boolean} values denoting scrollable axis, DOM element to attach drag handlers to. Defaults to element attribute `pk-scroll` or `y`
@return Object {Object} Consisting of original DOM element (item `0`)
@chainable
*/
(function(pk) {
    // HELPERS FOR jQUERY+ANGULAR
    if (typeof jQuery === 'object') {
        // jquery available
        jQuery.fn.extend({
            pkScroll: function(axis) {
                pk.scroll({
                    element: this[0],
                    axis: axis
                });
            }
        });
    }
    if (typeof angular === 'object') {
        // angular available
        ( 

            function() {
                angular.module('pk-scroll', ['ng'])
                    .directive('pkScroll', function() {
                        return {
                            restrict: 'A',
                            link: function(scope, el) {
                                pk.scroll({
                                    element: el[0],
                                    axis: el[0].getAttribute('pk-scroll')
                                });
                            }
                        };
                    });
            })();
    }
    pk.scroll = function(opt) {

        var el = opt.element;
        // INIT SCROLL STRUCTURE

        var tpl = "<div class='pk-scroll-container'>\
            <" + el.nodeName + " class='pk-scroll-content'>\
                " + el.innerHTML + "\
            </" + el.nodeName + ">\
            <div class='pk-scroll-trackY'>\
                <div class='pk-scroll-floatY'></div>\
            </div>\
            <div class='pk-scroll-trackX'>\
                <div class='pk-scroll-floatX'></div>\
            </div>\
        </div>";
        el.innerHTML = '';
        el = pk.replaceEl(el, tpl);
        var container = el.children[0],
            trackY = el.children[1],
            floatY = trackY.children[0],
            trackX = el.children[2],
            floatX = trackX.children[0];
        // INIT VARIABLES
        var
            floatYh = 0,
            floatXw = 0,
            allowY = false,
            allowX = false,
            percY = 0,
            percX = 0,
            contentH = 0,
            contentW = 0,
            containerH = 0,
            containerW = 0,
            contentWidth = 0,
            contentHeight = 0,
            containerWidth = 0,
            containerHeight = 0,
            scrollDir = opt.axis ? opt.axis.toLowerCase() : (pk.attribute(el, 'pk-scroll') ? pk.attribute(el, 'pk-scroll') : "y");
        if (pk.getStyle(el, 'position') === "static") {
            el.style.position = "relative";
        }

        pk.bindEvent("scroll", container, function() {
            percY = container.scrollTop / (contentH - containerH);
            percX = container.scrollLeft / (contentW - containerW);
            percY = percY < 0 ? 0 : percY > 1 ? 1 : percY;
            percX = percX < 0 ? 0 : percX > 1 ? 1 : percX;
            floatY.style.top = (containerH - floatYh) * percY + 'px';
            floatX.style.left = (containerW - floatXw) * percX + 'px';
        });

        function resolveDimensions() {
            contentH = container.scrollHeight;
            contentW = container.scrollWidth;
            containerH = el.offsetHeight;
            containerW = el.offsetWidth;
            if (scrollDir.indexOf("y") > -1 && contentH > containerH) {
                allowY = true;
                pk.addClass(el, 'pk-scroll-enableY');
                floatYh = floatY.offsetHeight;
                container.scrollTop = (contentH - containerH) * percY;
            } else {
                allowY = false;
                pk.removeClass(el, 'pk-scroll-enableY');
                container.scrollTop = 0;
            }
            if (scrollDir.indexOf("x") > -1 && contentW > containerW) {
                allowX = true;
                pk.addClass(el, 'pk-scroll-enableX');
                floatXw = floatX.offsetWidth;
                container.scrollLeft = (contentW - containerW) * percX;
            } else {
                allowX = false;
                pk.removeClass(el, 'pk-scroll-enableX');
                container.scrollLeft = 0;
            }
        }
        resolveDimensions();

        setInterval(function() {
            var widthContainer = el.offsetWidth,
                heightContainer = el.offsetHeight,
                widthContent = container.scrollWidth,
                heightContent = container.scrollHeight;
            if (widthContainer !== containerWidth || heightContainer !== containerHeight || widthContent !== contentWidth || heightContent !== contentHeight) {
                contentWidth = widthContent;
                contentHeight = heightContent;
                containerWidth = widthContainer;
                containerHeight = heightContainer;
                resolveDimensions();
            }
        }, 500);

        // DRAG HANDLERS

        if (allowY) {
            pk.drag({
                element: floatY,
                move: {
                    y: true
                },
                container: {
                    element: trackY
                },
                listeners: {
                    dragging: function() {
                        container.scrollTop = (contentH - containerH) * (floatY.offsetTop / (trackY.offsetHeight - floatY.offsetHeight));
                    }
                }
            });
        }
        if (allowX) {
            pk.drag({
                element: floatX,
                move: {
                    x: true
                },
                container: {
                    element: trackX
                },
                listeners: {
                    dragging: function() {

                        container.scrollLeft = (contentW - containerW) * (floatX.offsetLeft / (trackX.offsetWidth - floatX.offsetWidth));
                    }
                }
            });
        }
        pk.bindEvent("click", floatY, function(e) {
            pk.preventBubble(e);
        });
        pk.bindEvent("click", floatX, function(e) {
            pk.preventBubble(e);
        });

        // TRACK CLICKING HANDLERS
        pk.bindEvent("click", trackY, function(e) {
            container.scrollTop = (pk.getEventOffset(e).y / containerH * (contentH - containerH));
        });
        pk.bindEvent("click", trackX, function(e) {
            container.scrollLeft = (pk.getEventOffset(e).x / containerW * (contentW - containerW));
        });

        // MOUSE WHEEL HANDLERS
        function mouseScroll(e) {
            var offset = 0.1;
            if (e.wheelDelta > 0 || e.detail < 0) {
                offset = offset * -1;
            }
            if (allowY) {
                container.scrollTop = Math.round(container.scrollTop + (contentH - containerH) * offset);
            } else {
                container.scrollLeft = Math.round(container.scrollLeft + (contentW - containerW) * offset);
            }
            /* Stop wheel propogation (prevent parent scrolling) */
            pk.preventBubble(e);
        }

        pk.bindEvent("mousewheel", container, mouseScroll);

        // TOUCH EVENT HANDLERS

        function getXy(e) {
            // touch event
            if (e.targetTouches && (e.targetTouches.length >= 1)) {
                return {
                    x: e.targetTouches[0].clientX,
                    y: e.targetTouches[0].clientY
                };
            }
            // mouse event
            return {
                x: e.clientX,
                y: e.clientY
            };
        }

        var pressed = false,
            startPos = {};

        function tap(e) {
            pressed = true;
            startPos = getXy(e);
            e.preventDefault();
            e.stopPropagation();
            return false;
        }

        function release(e) {
            pressed = false;
            e.preventDefault();
            e.stopPropagation();
            return false;
        }

        function drag(e) {
            var endPos, deltaX, deltaY;
            if (pressed) {
                endPos = getXy(e);
                deltaY = startPos.y - endPos.y;
                deltaX = startPos.x - endPos.x;
                if (deltaY > 2 || deltaY < -2) {
                    startPos.y = endPos.y;
                    container.scrollTop += deltaY;

                }
                if (deltaX > 2 || deltaX < -2) {
                    startPos.x = endPos.x;
                    container.scrollLeft += deltaX;
                }
            }
            e.preventDefault();
            e.stopPropagation();
            return false;
        }
        if (typeof window.ontouchstart !== 'undefined') {
            pk.bindEvent('touchstart', container[0], tap);
            pk.bindEvent('touchmove', container[0], drag);
            pk.bindEvent('touchend', window, release);
        }

        // KEYBOARD HANDLERS    
        container.setAttribute("tabindex", 0);
        pk.bindEvent('keydown', container, function(e) {
            if (document.activeElement !== container) {
                return;
            }
            if (allowY) {
                switch (e.keyCode) {
                    case 38: //up cursor					
                        container.scrollTop -= containerH * 0.1;
                        pk.preventBubble(e);
                        break;
                    case 40: //down cursor
                    case 32: //spacebar
                        container.scrollTop += containerH * 0.1;
                        pk.preventBubble(e);
                        break;
                    case 33: //page up
                        container.scrollTop -= containerH;
                        pk.preventBubble(e);
                        break;
                    case 34: //page down
                        container.scrollTop += containerH;
                        pk.preventBubble(e);
                        break;
                    case 36: //home
                        container.scrollTop = 0;
                        pk.preventBubble(e);
                        break;
                    case 35: //end
                        container.scrollTop = contentH;
                        pk.preventBubble(e);
                        break;
                }
            }
            if (allowX) {
                switch (e.keyCode) {
                    case 37: //left cursor
                        container.scrollLeft -= containerW * 0.1;
                        pk.preventBubble(e);
                        break;
                    case 39: //right cursor
                        container.scrollLeft += containerW * 0.1;
                        pk.preventBubble(e);
                        break;
                }
            }
            return {
                0: el
            };

        });
    };
    return pk;
})(pk);

var pk = pk || {};
/**
Create a new select control. Controls can be converted from existing `select` or `ul` elements, or generated by passing an `options` parameter

HTML

	<!-- Generate from an existing element -->
	
    <select id='selectFromEl'>
        <option value='val1'>
            option 1
        </option>
        <option value='val2'>
            option 2
        </option>
        <option value='val3'>
            option 3
        </option>
        <option value='val4'>
            option 4
        </option>
        <option value='val5'>
            option 5
        </option>
    </select>
	
	<!-- Generate from passing an options object -->
	
	<div id='selectFromObject'></div>

Javascript
	
	// Single select with no dropdown and pre-selected value
	
	pk.select({
		element: document.getElementById('selectFromEl'),
		value: 'val3'
	});	
	
	// Multiple select with dropdown
	
	pk.select({
		element: document.getElementById('selectFromObject'),
		options:[
			{
				value:'val1',
				name:'value 1'
			},
			{
				value:'val2',
				name:'value 2'
			},
			{
				value:'val3',
				name:'value 3'
			},
			{
				value:'val4',
				name:'value 4'
			},
			{
				value:'val5',
				name:'value 5'
			},
		]
	});	
		
	
@class pk.select
@constructor
@param options {Object}
@param options.element {Object} DOM element to convert to control
@param options.options {Array} Object array of control options
@param options.options.value {String} Option value
@param options.options.name {String} Option name (displayed label)
@param options.options.selected {Boolean} Option selected state
@param [options.value=0] {String} Value of initially selected option, defaults to the attribute value set on the passed element, or `0`
@param [options.name=pk-select-RandInt] {String} Name of underlying input control, defaults to the attribute value set on the passed element, or `pk-select-RandInt`
@param [options.placeholder=string] {String} Placeholder when no options selected, defaults to the attribute value set on the passed element, or `Please select...`
@param [options.multiple=false] {Boolean} Whether to allow multiple options to be selected, defaults to the attribute value set on the passed element, or `false`
@param [options.dropdown=false] {Boolean} Display options in dropdown list
@param [options.tabindex=0] {Number} Tabindex of control, defaults to the attribute value set on the passed element, or `0`
@param [options.disabled=false] {Boolean} Disabled state of control, defaults to the attribute value set on the passed element, or `false`
@return Object {Object} Consisting of original DOM element (item `0`) and class methods (see below)
@chainable
*/
(function(pk) {
    pk.select = function(opt) {

        var el = opt.element,
            options = opt.options || [],
            inputValue = opt.value || pk.attribute(el, 'value') || [],
            inputName = opt.name || pk.attribute(el, 'name') || 'pk-select-' + pk.getRand(1, 999),
            dropdown = Boolean(opt.dropdown),
            inputMultiple = (Boolean(opt.multiple) === true || pk.attribute(el, 'multiple')) ? true : false,
            inputPlaceholder = opt.placeholder || pk.attribute(el, 'placeholder') || 'Please select...',
            // listeners=opt.listeners === undefined ? {} : opt.listeners,            
            inputDisabled = (opt.disabled || el.getAttribute('disabled')) ? 'disabled' : '',
            inputTabIndex = opt.tabindex || el.getAttribute('tabindex') || 0;

        inputName = (inputMultiple && inputName.indexOf('[]') === -1) ? inputName + '[]' : inputName.replace('[]', '');

        // input value is now an array
        inputValue = pk.toArr(inputValue);

        // populate options if none present and the underlying element is SELECT or UL
        if (options.length === 0 && (el.nodeName === "SELECT" || el.nodeName === "UL")) {
            for (var i = 0; i < el.children.length; i++) {
                var oVal = pk.attribute(el.children[i], 'value'),
                    oName = el.children[i].innerHTML;
                oVal = oVal || oName;
                if (pk.attribute(el.children[i], 'selected') && inputValue.indexOf(oVal) === -1) {
                    inputValue.push(oVal);
                }
                options.push({
                    name: oName,
                    value: oVal
                });
            }
        }

        /*jshint multistr:true */
        var tpl = "<div class='pk-select " + (inputMultiple ? 'pk-select-multiple' : '') + " " + (dropdown ? 'pk-select-dropdown' : '') + " " + (inputDisabled ? 'pk-disabled' : '') + "' tabindex='" + inputTabIndex + "'>\
                <input type='hidden' name='" + inputName + "'/>\
                <div class='pk-select-value " + (!inputValue || inputValue.length < 1 ? 'pk-placeholder' : '') + "'>sdsd</div>\
            <ul>";
        for (var o = 0; o < options.length; o++) {
            tpl += "<li class='pk-option' data-value='" + options[o].value + "'>" + options[o].name + "</li>";
        }
        tpl += "</ul></div>";

        el.innerHTML = '';
        el = pk.replaceEl(el, tpl);

        var triggerEl = el.children[1],
            inputEl = el.children[0],
            optionsEl = el.children[2];

        if (dropdown && !inputDisabled) {
            var overlayEl = document.body.insertBefore(pk.createEl("<div class='pk-overlay'></div>"), document.body.children[0]);
            pk.bindEvent('click', overlayEl, function() {
                pk.removeClass(overlayEl, 'pk-show');
                pk.toggleClass(el, 'pk-show');
            });
            pk.bindEvent('click', el, function(e) {

                if (pk.attribute(e.target, 'data-value') && pk.hasClass(e.target, 'pk-select-value-tag')) {
                    inputValue = pk.collide(inputValue, pk.attribute(e.target, 'data-value'), 2);
                    updateValue();
                }


                if (pk.hasClass(e.target, 'pk-select-value-tag') || (inputMultiple && pk.hasClass(e.target, 'pk-option')) || !pk.hasClass(el, 'pk-show')) {
                    pk.addClass(overlayEl, 'pk-show');
                    pk.addClass(el, 'pk-show');
                } else {
                    pk.removeClass(overlayEl, 'pk-show');
                    pk.removeClass(el, 'pk-show');
                }

            });
        }


        function updateValue() {
            var valueHTML = '';
            if (!inputMultiple) {
                inputValue.splice(1, inputValue.length - 1);
            }
            for (var o = 0; o < options.length; o++) {
                options[o].selected = (inputValue.indexOf(options[o].value) !== -1) ? true : false;
                pk.toggleClass(optionsEl.children[o], 'pk-selected', options[o].selected);
                if (options[o].selected) {
                    valueHTML = inputMultiple ? valueHTML += "<span class='pk-select-value-tag' data-value='" + options[o].value + "'>" + options[o].name + "</span>" : options[o].name;
                }
            }
            triggerEl.innerHTML = valueHTML ? valueHTML : inputPlaceholder;
            if (inputValue.length < 1) {
                pk.addClass(triggerEl, 'pk-placeholder');
            } else {
                pk.removeClass(triggerEl, 'pk-placeholder');
            }
            // update underlying input element
            inputEl.value = inputMultiple ? inputValue : inputValue.join('');
        }
        if (!inputDisabled) {
            pk.bindEvent('click', optionsEl, function(e) {
                if (e.target.nodeName === "LI") {
                    inputValue = inputMultiple ? pk.collide(inputValue, options[pk.getIndex(e.target)].value, 3) : pk.collide(inputValue, options[pk.getIndex(e.target)].value);
                    updateValue();
                }
            });
        }
        updateValue();
        return {
            0: el
        };
    };
    return pk;
})(pk);

var pk = pk || {};
/**
Create a new slider control

HTML:

	<input id='slider' />
	
Javascript:

	pk.slider({
		element: document.getElementById('slider'),
		units: 'mm',
		min: 30,
		max: 980, 
		value: 133
	});
	
@class pk.slider
@constructor
@param options {Object}
@param options.element {Object} DOM element to convert to control
@param [options.value=0] {Number} Initial value, defaults to the attribute value set on the passed element, or `0`
@param [options.axis=x] {String} Either `x` (horizontal) or `y` (vertical), ignored if slider is circle
@param [options.min=0] {Number} Minimum value
@param [options.max=100] {Number} Maximum value
@param [options.decimals=0] {Number} Number of decimal places
@param [options.name=pk-slider-RandInt] {String} Name of underlying input control, defaults to the attribute value set on the passed element, or `pk-slider-RandInt`
@param [options.tabindex=0] {Number} Tabindex of control, defaults to the attribute value set on the passed element, or `0`
@param [options.disabled=false] {Boolean} Disabled state of control, defaults to the attribute value set on the passed element, or `false`
@param [options.listeners] {Object} Object array of event listeners to bind to underlying input(s)
@param [options.circle=false] {Object} Object array of properties to define circular slider
@param [options.circle.stroke=20] {Number} Stroke width of slider circle
@param [options.circle.stroke.inner=options.circle.stroke.outer] {Number} Stroke width of inner slider circle
@param [options.circle.stroke.outer=options.circle.stroke.inner] {Number} Stroke width of outer slider circle
@return Object {Object} Consisting of original DOM element (item `0`) and class methods (see below)
@chainable
*/
(function(pk) {
    pk.slider = function(opt) {
        var el = opt.element,
            units = opt.units === undefined ? '' : opt.units,
            listeners = opt.listeners === undefined ? {} : opt.listeners,
            min = opt.min || 0,
            max = opt.max || 100,
            decimals = opt.decimals || 0,
            axis = opt.axis || "x",
            range = Math.abs(max - min),
            inputValue = opt.value || el.getAttribute('value') || 0,
            inputDisabled = (opt.disabled || el.getAttribute('disabled')) ? 'disabled' : '',
            inputName = opt.name || el.getAttribute('name') || 'pk-slider-' + pk.getRand(1, 999),
            inputTabIndex = opt.tabindex || el.getAttribute('tabindex') || 0,
			circle = opt.circle || false;
			// circle=false;
			if(circle){			
				circle={
					stroke:circle.stroke || 20,
					start:circle.start || 0,
					length:!circle.length || circle.length===360 ? null : circle.length
				};
				circle.stroke = {
					inner:circle.stroke.inner || circle.stroke.outer || circle.stroke,
					outer: circle.stroke.outer || circle.stroke.inner || circle.stroke
				};
			}

        if (!axis || !(axis.indexOf("x") < 0 || axis.indexOf("y") < 0)) {
            axis = "x";
        }

        var tpl = "<div class='pk-slider pk-slider-" + axis + " " + (inputDisabled ? 'pk-disabled' : '') + " " +(circle ? 'pk-slider-circle': '') + "' tabindex='" + inputTabIndex + "'>\
            <input type='hidden' name='" + inputName + "' " + inputDisabled + " value='" + inputValue + "'/>\
        </div>";
		
        el = pk.replaceEl(el, tpl);
		var l=pk.layout(el);
		var d = l.height > l.width ? l.width : l.height;
		function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
		  var angleInRadians = (angleInDegrees-90) * Math.PI / 180.0;
		  return {
			x: centerX + (radius * Math.cos(angleInRadians)),
			y: centerY + (radius * Math.sin(angleInRadians))
		  };
		}

		function describeArc(x, y, radius, startAngle, endAngle){
			endAngle = endAngle == 360 || endAngle > 360 ? 359.9 : endAngle;			
			if(circle.length){
				startAngle=endAngle-(circle.length / 2);
				endAngle=endAngle+(circle.length / 2);
			}
			return pk.svg.arcPath(x, y, radius, startAngle, endAngle);       
		}
		var pathEl='';
		var innerTpl='';
		if(circle){			
			innerTpl="<svg height='"+d+"' width='"+d+"' xmlns='http://www.w3.org/2000/svg' version='1.1'>\
			   <circle class='pk-slider-circle' cx='"+d/2+"' cy='"+d/2+"' r='"+((d-Math.max(circle.stroke.inner, circle.stroke.outer))/2)+"' stroke='black' stroke-width='"+circle.stroke.outer+"' fill='none' />\
			   <path x='"+d/2+"' y='"+d/2+"' fill='none' d='' stroke-width='"+circle.stroke.inner+"'/>\
			</svg>";
			el.appendChild(pk.createEl(innerTpl));
			el.appendChild(pk.createEl("<span class='pk-slider-monitor'><span class='pk-slider-value'></span><span class='pk-slider-units'></span></span>"));
			
			pathEl = el.children[1].childNodes[3]; 
			pk.attribute(pathEl, 'd', describeArc(d/2, d/2, (d-Math.max(circle.stroke.inner, circle.stroke.outer))/2, 0, 360));	
		}else{
			// get biggest dimension
			innerTpl="<div class='pk-slider-bar pk-animated'>\
                <span class='pk-slider-value'></span><span class='pk-slider-units'></span>\
            </div>";
			el.appendChild(pk.createEl(innerTpl));
		}
		
        var indicatorEl = circle ? el.children[1].childNodes[1] : el.children[1],
            inputEl = el.children[0],
            valueEl = circle ? el.children[2].children[0] : indicatorEl.children[0],
            unitsEl = circle ? el.children[2].children[1] : indicatorEl.children[1];

        /**
        Fired on slide event starting
        @event slidestart
        @param element {Object} Element event fired on
        @param event {Object} Event object
        */

        /**
        Fired on during slide event
        @event sliding
        @param element {Object} Element event fired on
        @param event {Object} Event object
        */

        /**
        Fired on slide event ending
        @event slideend
        @param element {Object} Element event fired on
        @param event {Object} Event object
        */
        pk.bindListeners(listeners, inputEl);
        pk.drag({
            element: el,
            contain: {
                element: el
            },
            move: false,
            listeners: {
                dragging: function(el, e) {
                    if (obj.disabled()) {
                        return false;
                    }			
					var perc=0;
				    var p =pk.layout(el,e);
					if(circle){
						var origin={
							x:p.left+(p.width/2),
							y:p.top+(p.height/2)
						}
						if(e.pageX >= origin.x){
							perc = 90-Math.atan((origin.y-e.pageY)/(e.pageX-origin.x))*180/Math.PI;					 
						}else{					 
							perc = 180+(90-Math.atan((origin.y-e.pageY)/(e.pageX-origin.x))*180/Math.PI);
						}		
						perc=perc/360;						
					}else{
						perc = axis === "x" ? (e.dragDist.x + e.dragOffset.x) / pk.layout(el).width : 1 - (e.dragDist.y + e.dragOffset.y) / pk.layout(el).height;
						perc = perc < 0 ? 0 : perc;
						perc = perc > 1 ? 1 : perc;
						
					}
					obj.val(min + Math.round(perc * range));
                    if (listeners && listeners.sliding) {
                        listeners.sliding(el, e);
                    }
                },
                dragstart: function(el, e) {
				
                    if (obj.disabled()) {
                        return false;
                    }
                    if (listeners && listeners.slidestart) {
                        listeners.slidestart(el, e);
                    }
                    pk.removeClass(indicatorEl, 'pk-animated');
                },
                dragend: function(el, e) {
                    if (obj.disabled()) {
                        return false;
                    }
                    if (listeners && listeners.slideend) {
                        listeners.slideend(el, e);
                    }
                    pk.addClass(indicatorEl, 'pk-animated');
                }
            }
        });
		
        pk.bindEvent('click', el, function(e) {
            if (obj.disabled()) {
                return false;
            }
			var perc=0;
			if(circle){			
				var p =pk.layout(el,e);
				var origin={
					x:p.left+(p.width/2),
					y:p.top+(p.height/2)
				}
				if(e.pageX >= origin.x){
					perc = 90-Math.atan((origin.y-e.pageY)/(e.pageX-origin.x))*180/Math.PI;					 
				}else{					 
					perc = 180+(90-Math.atan((origin.y-e.pageY)/(e.pageX-origin.x))*180/Math.PI);
				}		
				perc=perc/360;					
			}else{
				perc = axis === "x" ? ((e.clientX - el.getBoundingClientRect().left) / pk.layout(el).width) : 1 - ((e.clientY - el.getBoundingClientRect().top) / pk.layout(el).height);
			}
            obj.val(min + Math.round(perc * range));
        });
        pk.bindEvent("mousewheel", el, function(e) {
            pk.preventBubble(e);
            if (obj.disabled()) {
                return false;
            }
            var offset = 0.1;
            if (e.wheelDelta < 0 || e.detail > 0) {
                offset = offset * -1;
            }
            obj.val(range * offset + parseInt(obj.val(), 0));
        });
        /**
        Gets or sets control value
        @method val
        @param [value] {Number} Value to set
        @return {Number} Returns current value
        */

        /**
        Gets or sets control disabled state
        @method disabled
        @param [boolean] {Boolean} Disabled state
        @return {Boolean} Returns disabled state
        */
        var obj = {
            0: el,
            val: function(val, force) {
                if (val === undefined || (obj.disabled() && !force)) {
                    return inputEl.value; 
                }
                val = val < min ? min : val;
                val = val > max ? max : val;
                inputEl.value = val;
				if(circle){  
					pk.attribute(pathEl, 'd', describeArc(d/2, d/2, (d-Math.max(circle.stroke.inner, circle.stroke.outer))/2, 0, (val - min) *360 / range));						
				}else{
					if (axis === "x") {
						indicatorEl.style.width = (val - min) * 100 / range + '%';
					} else {
						indicatorEl.style.height = (val - min) * 100 / range + '%';
					}
				}
                valueEl.innerHTML = val.toFixed(decimals);
                unitsEl.innerHTML = units;
				if (listeners && listeners.change) {
					listeners.change(el, val, inputEl);
				}
            },
            disabled: function(val) {
                if (val !== undefined) {
                    pk.toggleClass(el, 'pk-disabled', val);
                    pk.attribute(inputEl, 'disabled', val);
                }
                return pk.attribute(inputEl, 'disabled');
            }
        };
        obj.val(inputValue, true);
        return obj;
    };
    return pk;
})(pk);

var pk = pk || {};

/**
Create a new switch control

HTML: 

	<input type='switch' id='switch' />

Javascript:
	
	pk.switch({
		element: document.getElementById('switch')
	});
	
@class pk.switch
@constructor
@param options {Object}
@param options.element {Object} DOM element to convert to control
@param [options.value] {Boolean} Initial value
@param [options.name=pk-switch-RandInt] {String} Name of underlying input control, defaults to the attribute value set on the passed element, or `pk-switch-RandInt`
@param [options.tabindex=0] {Number} Tabindex of control, defaults to the attribute value set on the passed element, or `0`
@param [options.disabled=false] {Boolean} Disabled state of control, defaults to the attribute value set on the passed element, or `false`
@param [options.listeners] {Object} Object array of event listeners to bind to underlying input(s)
@return Object {Object} Consisting of original DOM element (item `0`) and class methods (see below)
@chainable
*/
(function(pk) {
    pk.switch = function(opt) {
        var el = opt.element,
            //    listeners = opt.listeners === undefined ? {} : opt.listeners,
            inputValue = opt.value || el.getAttribute('value') || true,
            inputLabel = opt.label || el.getAttribute('label') || el.innerHTML,
            inputDisabled = (opt.disabled || el.getAttribute('disabled')) ? 'disabled' : '',
            inputName = opt.name || el.getAttribute('name') || 'pk-switch-' + pk.getRand(1, 999),
            listeners = opt.listeners === undefined ? {} : opt.listeners,
            inputTabIndex = opt.tabindex || el.getAttribute('tabindex') || 0;

        /*jshint multistr:true */
        var str = "<label class='pk-switch' for='" + inputName + "'>\
			<input type = 'checkbox'  id = '" + inputName + "'  name = '" + inputName + "' tabindex = '" + inputTabIndex + "' / >\
            <span class = 'pk-label' > " + inputLabel + " </span>\
			<span class = 'pk-indicator' > " + inputLabel + " </span>\
		</label>";
		
        el.innerHTML = '';
        el = pk.replaceEl(el, str);
		
		pk.bindEvent("mousewheel", el, function(e) { 
		 	pk.preventBubble(e); 
			if (e.wheelDelta > 0 || e.detail < 0) {
                obj.val(true);
            }else{
				obj.val(false);
			}
        });
        /**
        Gets or sets control value
        @method val
        @param [value] {String} Value to set
        @return {String} Returns current value
        */

        /**
        Gets or sets control disabled state
        @method disabled
        @param [boolean] {Boolean} Disabled state
        @return {Boolean} Returns disabled state
        */
        var obj = {
            0: el,
            val: function(val) {
                if (val === undefined) {
                    return pk.attribute(el.children[0], 'checked');
                }
                pk.attribute(el.children[0], 'checked', Boolean(val));
            },
            disabled: function(val) {
                if (val !== undefined) {
                    pk.toggleClass(el, 'pk-disabled', Boolean(val));
                    pk.attribute(el.children[0], 'disabled', Boolean(val));
                }
                return pk.attribute(el.children[0], 'disabled');
            }
        };
        obj.val(inputValue);
        if (inputDisabled) {
            obj.disabled(true);
        }
        pk.bindListeners(listeners, el.children[0]);
        return obj;
    };
    return pk;
})(pk);

var pk = pk || {};
/**
Create a new toggle control

HTML:

	<input id='toggle' />

Javascript:

	pk.toggle({
		element: document.getElementById('toggle'),
		options: [{
			value: true,
			name: 'yes'
		}, {
			value: false,
			name: 'no'
		}, {
			value: 'other',
			name: 'other'
		}],
		value: false
	});
	
@class pk.toggle
@constructor
@param options {Object}
@param options.element {Object} DOM element to convert to control
@param options.options {Object} Object array of control options
@param options.options.value {String} Option value
@param options.options.name {String} Option name (displayed label)
@param [options.value=0] {String} Value of initially selected option, defaults to the attribute value set on the passed element, or `0`
@param [options.name=pk-toggle-RandInt] {String} Name of underlying input control, defaults to the attribute value set on the passed element, or `pk-toggle-RandInt`
@param [options.tabindex=0] {Number} Tabindex of control, defaults to the attribute value set on the passed element, or `0`
@param [options.disabled=false] {Boolean} Disabled state of control, defaults to the attribute value set on the passed element, or `false`
@param [options.listeners] {Object} Object array of event listeners to bind to underlying input(s)
@return Object {Object} Consisting of original DOM element (item `0`) and class methods (see below)
@chainable
*/
(function(pk) {
    pk.toggle = function(opt) {
        var el = opt.element,
            options = opt.options || [],
            // more complex as can take true/false values
            inputValue = opt.value !== undefined ? opt.value : pk.attribute(el, 'value') !== undefined ? pk.attribute(el, 'value') : options[0].value,
            listeners = opt.listeners === undefined ? {} : opt.listeners,
            inputDisabled = (opt.disabled || el.getAttribute('disabled')) ? 'disabled' : '',
            inputName = opt.name || el.getAttribute('name') || 'pk-toggle-' + pk.getRand(1, 999),
            inputTabIndex = opt.tabindex || el.getAttribute('tabindex') || 0;

        if (!options) {
            return;
        }

        var tpl = "<div class='pk-toggle " + (inputDisabled ? 'pk-disabled' : '') + "' tabindex='" + inputTabIndex + "'>\
			<input type='hidden' name = '" + inputName + "' value='" + inputValue + "'/>\
			<div class='pk-toggle-indicator' style='width:" + (100 / options.length) + "%'></div>\
		</div>";

        tpl += "";
        el.innerHTML = '';
        el = pk.replaceEl(el, tpl);

        var optionEl = [];
        for (var o = 0; o < options.length; o++) {
            var oEl = pk.createEl("<div class='pk-option' style='width:" + (100 / options.length) + "%' data-value='" + options[o].value + "'>" + options[o].name + "</div>");
            el.appendChild(oEl);
            optionEl.push(oEl);
        }

        var inputEl = el.children[0],
            indicatorEl = el.children[1];
        /**
        Gets or sets control value
        @method val
        @param [value] {String} Value to set
        @return {String} Returns current value
        */

        /**
        Gets or sets control disabled state
        @method disabled
        @param [boolean] {Boolean} Disabled state
        @return {Boolean} Returns disabled state
        */
        var obj = {
            0: el,
            val: function(val) {
                if (val === undefined) {
                    return inputEl.value;
                }
                val = val.toString() || options[0].value.toString();
                for (var o = 0; o < options.length; o++) {
                    if (options[o].value.toString() === val) {
                        indicatorEl.style.left = parseInt(o, 0) * 100 / options.length + '%';
                        inputEl.value = val;
                        pk.addClass(optionEl[o], 'pk-selected');
                    } else {
                        pk.removeClass(optionEl[o], 'pk-selected');
                    }
                }
            },
            disabled: function(val) {
                if (val !== undefined) {
                    pk.toggleClass(el, 'pk-disabled', val);
                    pk.attribute(inputEl, 'disabled', val);
                }
                return pk.attribute(inputEl, 'disabled');
            }
        };
        obj.val(inputValue);

        function clickOpt(e) {
            obj.val(pk.attribute(e.target, 'data-value'));
        }
        for (o = 0; o < options.length; o++) {
            pk.bindListeners(listeners, optionEl[o]);
            if (!inputDisabled) {
                pk.bindEvent('click', optionEl[o], clickOpt);
            }
        }
        return obj;
    };
    return pk;
})(pk);

var pk = pk || {};
/**
Class used for creating tooltips

HTML

    <span id='tooltip'>Show Tooltip</span>

Javascript:

	pk.tooltip({
		element:document.getElementById('tooltip'),
		content:'Tooltip content',
		position:'left'
	});

@class pk.tooltip
@constructor
@param options {Object}
@param options.element {Object} DOM element to apply tooltip to
@param [options.content] {String} Tooltip content (`HTML` allowed)
@param [options.position=right] {String} Tooltip position (`top`, `right`, `bottom` or `left`)
@param [options.delay=500] {Number} Time in `ms` before tooltip is shown
@return Object {Object} Returns target element (item `0`)
@chainable
*/

(function(pk) {
	var ttEl=null;
	pk.tooltip=function(opt){
		if(!ttEl){
			ttEl=pk.createEl("<div class='pk-tooltip'></div>");
			document.body.appendChild(ttEl);
		}
		var delay=opt.delay || 500, timer=null;
		pk.bindEvent('mouseover', opt.element,function(){
			ttEl.innerHTML=opt.content;
			ttEl.style.display='block';	
			var tl=pk.layout(ttEl),
				pl=pk.layout(opt.element),
				t=0,l=0;
				opt.position=opt.position || 'right';		
			ttEl.style.display='';
			switch(opt.position){
				case "top":
					t=pl.top-tl.height;
					l=pl.left;
				break;
				case "bottom":
					t=pl.top+pl.height;
					l=pl.left;
				break;
				default:
				case "right":
					t=pl.top;
					l=pl.left + pl.width;
				break;				
				case "left": 
					t=pl.top;
					l=pl.left - tl.width;
				break;
			}
			ttEl.style.top=t+'px';
			ttEl.style.left=l+'px';
			pk.addClass(ttEl, 'pk-'+opt.position);		
			
			if(!timer){
				timer = setTimeout(function(){				
					pk.addClass(ttEl, 'pk-show');	
					clearTimeout(timer);
					timer=null;
				},delay);
			}
			
		});
		pk.bindEvent('mouseout', opt.element,function(){
			ttEl.innerHTML='';
			if(timer){	
				clearTimeout(timer);
				timer=null;
			}	
			pk.removeClass(ttEl, 'pk-'+opt.position);		
		});
		return {
			0:opt.element
		};
	};
    return pk;
})(pk);

var pk = pk || {};
/**
Utility class for converting color types and generating color schemes. 

<div class='info-well'>
For color conversion methods, where the expected parameter is an array e.g `[0,0,0]`, the method can also be passed a comma separated value string, e.g. `'0,0,0'`, from which an array will automatically be extrapolated.
</div>

@class pk.color
*/

(function(pk) {
    pk.color = {

        /**
        Convert a HEX color string to an RGB

            var color=pk.color.hex2rgb('#FF0000');
            // color = [255,0,0]

        @method hex2rgb 
		@param hex {String} HEX color string 
        @return {Array} Returns array of red, blue and green components
        */
        hex2rgb: function(hex) {
		
            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
                result, r, g, b;
				
			
            hex = hex.replace(shorthandRegex, function(r, g, b) {
                return r + r + g + g + b + b;
            });
            result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            r = parseInt(result[1], 16);
            g = parseInt(result[2], 16);
            b = parseInt(result[3], 16);
            return [r, g, b];
        },
        /**
        Convert an RGB array to a HEX color string

            var color=pk.color.rgb2hex([255,0,0]);
            // color = '#FF0000'

        @method rgb2hex
        @param rgb {Array} Array of red, blue and green components
        @return {String} Returns HEX color string
        */
        rgb2hex: function(rgb) {
			rgb=pk.toArr(rgb);
            var hex = '',
                h, i, c;
            for (i = 0; i < rgb.length; i += 1) {
                c = rgb[i];
                h = c.toString(16);
                h = (h.length === 1) ? "0" + h : h;
                hex += h;
            }
            return '#' + hex;
        },
        /**
        Convert an RGB array to a HSV array

            var color=pk.color.rgb2hsv([255,0,0]);
            // color = [0,100,100]

        @method rgb2hsv
        @param rgb {Array} Array of red, blue and green components
        @return {Array} Returns array of hue, saturation and value components
        */
        rgb2hsv: function(rgb) {		
			rgb=pk.toArr(rgb);
            var
                r = rgb[0],
                g = rgb[1],
                b = rgb[2],
                min = Math.min(r, g, b),
                max = Math.max(r, g, b),
                delta = max - min,
                h, s, v = max;
            v = Math.floor(max / 255 * 100);

            if (max !== 0) {
                s = Math.floor(delta / max * 100);
            } else {
                return [0, 0, 0];
            }
            if (delta === 0) {
                h = 0;
            } else {			
				if (r === max) {
					h = (g - b) / delta;
				} else if (g === max) {
					h = 2 + (b - r) / delta;
				} else {
					h = 4 + (r - g) / delta;
				}
            }
            h = Math.floor(h * 60);
            if (h < 0) {
                h += 360;
            }
            return [h, s, v];
        },
        /**
        Convert an HSV array to a RGB array

            var color=pk.color.hsv2rgb([0,100,100]);
            // color = [255,0,0]

        @method hsv2rgb
        @param hsv {Array} Array of hue, saturation and value components
        @return {Array} Returns array of red, blue and green components
        */
        hsv2rgb: function(hsv) {
			hsv=pk.toArr(hsv);
            var
                r, g, b, i, f, p, q, t, h = hsv[0],
                s = hsv[1],
                v = hsv[2];
            h = Math.max(0, Math.min(360, h));
            s = Math.max(0, Math.min(100, s));
            v = Math.max(0, Math.min(100, v));
            s /= 100;
            v /= 100;
            h = h === 360 ? 0 : h;
            if (s === 0) {
                r = g = b = v;
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }
            h /= 60;
            i = Math.floor(h);
            f = h - i;
            p = v * (1 - s);
            q = v * (1 - s * f);
            t = v * (1 - s * (1 - f));
            switch (i) {
                case 0:
                    r = v;
                    g = t;
                    b = p;
                    break;
                case 1:
                    r = q;
                    g = v;
                    b = p;
                    break;
                case 2:
                    r = p;
                    g = v;
                    b = t;
                    break;
                case 3:
                    r = p;
                    g = q;
                    b = v;
                    break;
                case 4:
                    r = t;
                    g = p;
                    b = v;
                    break;
                case 5:
                    r = v;
                    g = p;
                    b = q;
                    break;
            }
            r = Math.round(r * 255);
            g = Math.round(g * 255);
            b = Math.round(b * 255);
            return [r, g, b];
        },
        /**
        Convert an RGB array to a HSL array

            var color=pk.color.rgb2hsl([255,0,0]);
            // color = [0,100,50]

        @method rgb2hsl
        @param RGB {Array} Array of red, green and blue components
        @return {Array} Returns array of hue, saturation and lightness components
        */		
        rgb2hsl: function(rgb) {
			rgb=pk.toArr(rgb);
            var r = rgb[0],
                g = rgb[1],
                b = rgb[2];
            r /= 255;
            g /= 255;
            b /= 255;
            var max = Math.max(r, g, b),
                min = Math.min(r, g, b);
            var h, s, l = (max + min) / 2;
            if (max === min) {
                h = s = 0; // achromatic
            } else {
                var d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4;
                        break;
                }
                h /= 6;
            }
            return [h, s, l];
        },
        /**
        Convert an HSL array to a RGB array

            var color=pk.color.hsl2rgb([0,100,50]);
            // color = [255,0,0]

        @method hsl2rgb
        @param HSL {Array} Array of hue, saturation and lightness components
        @return {Array} Returns array of red, green and blue components
        */				
        hsl2rgb: function(hsl) {
			hsl=pk.toArr(hsl);
            var h = hsl[0],
                s = hsl[1],
                l = hsl[2],
                r, g, b;

            function hue2rgb(p, q, t) {
                if (t < 0) {
                    t += 1;
                }
                if (t > 1) {
                    t -= 1;
                }
                if (t < 1 / 6) {
                    return p + (q - p) * 6 * t;
                }
                if (t < 1 / 2) {
                    return q;
                }
                if (t < 2 / 3) {
                    return p + (q - p) * (2 / 3 - t) * 6;
                }
                return p;
            }
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {

                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }

            return [r * 255, g * 255, b * 255];
        },
        /**
        Convert a HEX color string to a HSL array

            var color=pk.color.hex2hsl('#FF0000');
            // color = [0,100,50]

        @method hex2hsl
        @param hex {String} HEX color string
        @return {Array} Returns array of hue, saturation and lightness components
        */
        hex2hsl: function(hex) {
            return this.rgb2hsl(this.hex2rgb(hex));
        },
        /**
        Convert an HSL array to a HEX color string

            var color=pk.color.hsl2hex([0,100,50]);
            // color = '#FF0000'

        @method hsl2hex
        @param hsl {Array} Array of hue, saturation and lightness components
        @return {String} Returns HEX color string
        */
        hsl2hex: function(hsl) {
            return this.rgb2hex(this.hsl2rgb(pk.toArr(hsl)));
        },
		
        /**
        Convert an HSV array to HSL array

            var color=pk.color.hsv2hsl([0,100,100]);
            // color = [0,100,50]

        @method hsv2hsl
        @param hsv {Array} Array of hue, saturation and value components
        @return {Array} Returns array of hue, saturation and lightness components
        */
        hsv2hsl: function(hsv) {
            return this.rgb2hsl(this.hsv2rgb(pk.toArr(hsv)));
        },
			
        /**
        Convert an HSL array to HSV array

            var color=pk.color.hsl2hsv([0,100,50]);
            // color = [0,100,100]

        @method hsl2hsv
        @param hsl {Array} Array of hue, saturation and lightness components
        @return {Array} Returns array of hue, saturation and value components
        */
        hsl2hsv: function(hsl) {
            return this.rgb2hsv(this.hsl2rgb(pk.toArr(hsl)));
        },			
		
        /**
        Convert a HEX color string to a HSV array

            var color=pk.color.hex2hsv('#FF0000');
            // color = [0,100,100]

        @method hex2hsv
        @param hex {String} HEX color string
        @return {Array} Returns array of hue, saturation and value components
        */
        hex2hsv: function(hex) {
            return this.rgb2hsv(this.hex2rgb(hex));
        },
        /**
        Convert an HSV array to a HEX color string

            var color=pk.color.hsv2hex([0,100,100]);
            // color = '#FF0000'

        @method hsv2hex
        @param hsv {Array} Array of hue, saturation and value components
        @return {String} Returns HEX color string
        */
        hsv2hex: function(hsv) {
            return this.rgb2hex(this.hsv2rgb(pk.toArr(hsv)));
        },
        /**
        Generate a series of color biased (high saturation/lightness) randomized HEX color strings

            var palette=pk.color.random(5);
            // palette = ["#efa6a8", "#91abb", "#ebac2c", "#2b561", "#7b4b51"]

        @method random
        @param count {Number} Number of random colors to generate
        @return {Array} Returns Array of HEX color strings
        */
        random: function(count) {
            var palette = [],
                i;
            count = typeof count !== 'number' ? 1 : count; 
            for (i = 0; i < count; i += 1) {
            //    palette.push('#' + Math.floor(Math.random() * 16777215).toString(16));
				palette.push(this.hsv2hex([pk.getRand(0,360),100,pk.getRand(75,100)]));
            }
            return palette;
        }, 
        /**
        Generate (palette of) complementary color(s) from passed HEX color string
		
            var palette=pk.color.complement('#FF0000', 'split');
            // palette = ["#80ff00", "#00ffff", "#8000ff"]
			
            var palette=pk.color.complement('#FF0000', 'double');
            // palette = ["#80ff00", "#00ff40", "#00ffff", "#0040ff", "#8000ff"] 			
		
        @method complement
        @param hex {String} HEX color string
        @param [type] {String} Type of complementary palette to create, defaults to single complementary color, can be `split` or `double`
        @return {Array} Returns array of HEX color strings
        */
        complement: function(hex, type) {
            var count = 1,
                rotation = 180,
                scope = 0;
            switch (type) {
                case "split":
                    count = 3;
                    rotation = 180;
                    scope = 180;
                    break;
                case "double":
                    count = 5;
                    rotation = 180;
                    scope = 180;
                    break;
            }			
            return this.algorithmic({
				hex:hex,
				count:count,
				scope:scope,
				rotation:180
			});
        },
        /**
        Generate triadic color palette
		
            var palette=pk.color.triadic('#FF0000');
            // palette = ["#ff0000", "#00ff00", "#0000ff"] 
				
		
        @method triadic
        @param hex {String} HEX color string
        @return {Array} Returns array of HEX color strings
        */
        triadic: function(hex) {
            return this.algorithmic({hex:hex});
        },
        /**
        Generate tetradic color palette
		
            var palette=pk.color.triadic('#FF0000');
            // palette = ["#ff0000", "#80ff00", "#00ffff", "#8000ff"] 
			
        @method tetradic
        @param hex {String} HEX color string
        @return {Array} Returns array of HEX color strings
        */
        tetradic: function(hex) {
            return this.algorithmic({
				hex:hex,
				count:4
			});
        },
        /**
        Generate pentadic color palette
		
            var palette=pk.color.triadic('#FF0000');
            // palette = ["#ff0000", "#ccff00", "#00ff66", "#0066ff", "#cc00ff"] 
			
        @method pentadic
        @param hex {String} HEX color string
        @return {Array} Returns array of HEX color strings
        */
        pentadic: function(hex) {
            return this.algorithmic({
				hex:hex,
				count:5
			});
        },
        degrees: function(degrees, offset) {
            degrees += offset;
            if (degrees > 360) { 
                degrees -= 360;
            } else if (degrees < 0) {
                degrees += 360;
            }
            return degrees;
        },
        /**
        Generate a color from a percentage point between two colors
		
            var color=pk.color.percentage(0.5);
            // color = "#f2e600";
			
        @method percentage
        @param perc {Number} Percentage between first and second colors to generate color point from expressed as value between zero and one
		@param [hex1=#ff0000] {String} Starting color HEX value defaults to `#ff0000` red so 0% is red
		@param [hex2=#27ae62] {String} Starting color HEX value defaults to `#1ae500` green so 100% is green
        @return {String} Returns resulting HEX color
        */		
		percentage:function(perc, hex1, hex2){
			hex1=hex1 || '#ff0000';
			hex2=hex2 || '#27ae62';	
			var hsv1=pk.color.hex2hsv(hex1),
				hsv2=pk.color.hex2hsv(hex2);				
			return pk.color.hsv2hex([Math.round(hsv1[0]+perc*(hsv2[0]-hsv1[0])),Math.round(hsv1[1]+perc*(hsv2[1]-hsv1[1])),Math.round(hsv1[2]+perc*(hsv2[2]-hsv1[2]))]);
		},		
		/**
        Scale either hue, saturation or value of a color by a percentage amount
		
            var scale=pk.scale.percentage(0.5);
            // color = "#f2e600";
			
        @method scale
		@param hex {String} HEX color string
        @param perc {Number} Percentage to adjust color by
		@param [type=hue] {String} String, scale to adjust, either `hue`, `saturation` or `value`
		@param [abs] {Boolean} Define percentage as absolute value from base to max, defaults to relative value between current and max
        @return {String} Returns resulting HEX color
        */		
		scale:function(hex, perc, type, abs){ 
			type=type||'hue';			
			
			var hsv=this.hex2hsv(hex),
				adj=type==='hue' ? hsv[0] : type==='saturation' ? hsv[1] : hsv[2];
			perc = Math.abs(perc) > 1 ? perc/100 : perc;
			perc = abs===true ? perc*100 : adj+((type==='hue' ? 360 : 100)-adj)*perc;		
			return this.hsv2hex([type==="hue" ? adj : hsv[0], type==="saturation" ? perc : hsv[1], type==="value" ? perc : hsv[2]]);  
		},	
		/**
        Lighten a color by a percentage amount
		
            var color=pk.color.lighten('#840000', 70);
            // color = "#da0000";
			
        @method lighten
		@param hex {String} HEX color string
        @param perc {Number} Percentage to lighten color by
		@param [abs=lightness] {Boolean} Define percentage lightness as absolute value, defaults to relative
        @return {String} Returns resulting HEX color
        */		
		lighten:function(hex, perc, abs){ 
			perc = perc > 0 ? perc : -1*perc;
			return this.scale(hex, perc, 'value', abs); 
		},
		/**
        Darken a color by a percentage amount
		
            var color=pk.color.darken('#840000', 70);
            // color = "#da0000";
			
        @method darken
		@param hex {String} HEX color string
        @param perc {Number} Percentage to darken color by
		@param [abs=lightness] {Boolean} Define percentage lightness as absolute value, defaults to relative
        @return {String} Returns resulting HEX color
        */		
		darken:function(hex, perc, abs){  
			perc = perc < 0 ? perc : -1*perc;
			return this.scale(hex, perc, 'value', abs); 
		},	
		/**
        Saturate a color by a percentage amount
		
            var color=pk.color.saturate('#840000', 70);
            // color = "#820000";
			
        @method saturate
		@param hex {String} HEX color string
        @param perc {Number} Percentage to saturate color by
		@param [abs=lightness] {Boolean} Define percentage saturation as absolute value, defaults to relative
        @return {String} Returns resulting HEX color
        */		
		saturate:function(hex, perc, abs){ 
			perc = perc > 0 ? perc : -1*perc;
			return this.scale(hex, perc, 'saturation', abs); 
		},	
		/**
        Desaturate a color by a percentage amount
		
            var color=pk.color.desaturate('#840000', 70);
            // color = "#820000";
			
        @method saturate
		@param hex {String} HEX color string
        @param perc {Number} Percentage to saturate color by
		@param [abs=lightness] {Boolean} Define percentage desaturation as absolute value, defaults to relative
        @return {String} Returns resulting HEX color
        */		
		desaturate:function(hex, perc, abs){ 
			perc = perc > 0 ? perc : -1*perc;
			return this.scale(hex, perc, 'saturation', abs); 
		},		
        /**
        Generate algorithmic color palette
		
            var palette=pk.color.algorithmic ({hex:'#FF0000'});
            // palette = ["#ff0000", "#00ff00", "#0000ff"] 		
		
            var palette=pk.color.algorithmic ({hex:'#FF0000', count: 5});
            // palette = ["#ff0000", "#ccff00", "#00ff66", "#0066ff", "#cc00ff"]  			
		
            var palette=pk.color.algorithmic ({hex:'#FF0000', scope: 100, count:4});
            // palette = ["#ff00d4", "#ff0047", "#ff4700", "#ffd500"]

            var palette=pk.color.algorithmic ({hex:'#FF0000', type:'saturation', scope:50});
            // palette = ["#ffffff", "#ffbfbf", "#ff8080"]
			
        @method algorithmic
		@param options {Object} Algorithmic color transformation options
        @param options.hex {String} HEX color string
        @param [options.count=3] {Number} Number of colors to produce
        @param [options.type=hue] {String} Component to calculate on, either `hue`, `saturation` or `value`
        @param [options.scope=360] {Number} Number of degrees of rotation to consider
        @param [options.rotation=0] {Number} Number of degrees of rotation to calculate from
        @return {Array} Returns array of HEX color strings
        */
        // pick a point on the wheel, the number of degrees either side to cover and the split
        algorithmic: function(opt) {
			if(!opt.hex){return;}
			var hex=opt.hex,
				count = typeof opt.count === 'undefined' ? 3: opt.count,
				type = typeof opt.type === 'undefined' ? 'hue' : opt.type,
				scope = typeof opt.scope === 'undefined' ? 360 : opt.scope,
				rotation = typeof opt.rotation === 'undefined' ? 0 : opt.rotation,
                hsv = this.hex2hsv(hex),
                h = hsv[0],
                s = hsv[1],
                v = hsv[2],
                origin, steps, palette = [],
                offset, i;
            // if scope is 360, the start and end point are the same color, so should be avoided, otherwise enlargen the steps
            steps = (type === "hue" && (scope === 360 || scope === 0)) ? scope / count : scope / (count - 1);
            // if scope is 360, start on the current color
            origin = (scope === 360) ? h : this.degrees(this.degrees(h, rotation), -1 * scope / 2);
            for (i = 0; i < count; i += 1) {
                offset = steps * i;
                switch (type) {
                    case "hue":
                        palette.push(this.hsv2hex([this.degrees(origin, offset, 360) === 360 ? 0 : this.degrees(origin, offset, 360), s, v]));
                        break;
                    case "saturation":
                        palette.push(this.hsv2hex([h, offset, v]));
                        break;
                    case "value":
                    case "lightness":
                    case "brightness":
                        palette.push(this.hsv2hex([h, s, offset]));
                        break;
                }
            }
            return palette; 
        }
    };
    return pk;
})(pk);

var pk = pk || {};
/**
Utility class for SVG helpers


@class pk.svg
*/

(function(pk) {
    pk.svg = {
		polar2cartesian:function(centerX, centerY, radius, angleInDegrees) {
		  var angleInRadians = (angleInDegrees-90) * Math.PI / 180.0;
		  return {
			x: centerX + (radius * Math.cos(angleInRadians)),
			y: centerY + (radius * Math.sin(angleInRadians))
		  };
		},
		arcPath:function(x, y, radius, startAngle, endAngle){
			endAngle = endAngle == 360 || endAngle > 360 ? 359.9 : endAngle ;
			var start = this.polar2cartesian(x, y, radius, endAngle);
			var end = this.polar2cartesian(x, y, radius, startAngle);

			var arcSweep = endAngle - startAngle <= 180 ? "0" : "1";

			var d = [
				"M", start.x, start.y, 
				"A", radius, radius, 0, arcSweep, 0, end.x, end.y
			].join(" ");

			return d;       
		},
		arcPoint:function(degrees, r){		
			var a= degrees * Math.PI / 180,
			y=Math.cos(a) * r, 
			x=Math.sin(a) * r;
			return{
				x:x,
				y:y
			};			
		}
    };
    return pk;
})(pk);
